<html>
<head><meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />

<title>app04lev1sec2.html</title>
<link rel="stylesheet" href="../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../default.css" type="text/css">

<script type="text/JavaScript" src="../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "final/app04lev1sec2.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../index.html?page=sources%2Ffinal%2Fapp04lev1sec2.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../index.html?page=sources%2Ffinal%2Fapp04lev1sec2.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td align="right">
<div style="MARGIN-LEFT: 0.15in;"><a href=
"app04lev1sec1.html"><img src="images/prev.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Previous Page"></a> <a href=
"app04lev1sec3.html"><img src="images/next.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Next Page"></a></div>
</td>
</tr>
</table>

<div style="">
<div><a name="app04lev1sec2"></a>
<h3 class="docSection1Title" id="-100000">Main Language
Differences</h3>

<p class="docText"><a name="We will"></a>We will now take a more
structured look at the areas where C++ differs from Java and C#.
Many of the language differences are due to C++'s compiled nature
and commitment to performance. Thus, C++ does not check array
bounds at run-time, and there is no garbage collector to reclaim
unused dynamically allocated memory.</p>

<p class="docText"><a name="sake of"></a>For the sake of brevity,
C++ constructs that are nearly identical to their Java and C#
counterparts are not reviewed. In addition, some C++ topics are not
covered here because they are not necessary when programming using
Qt. Among these are defining template classes and functions,
defining union types, and using exceptions. For the whole story,
refer to a book such as <span class="docEmphasis"><a name=
"Programming Language"></a>The C++ Programming Language</span> by
Bjarne Stroustrup (Addison-Wesley, 2000) or <span class=
"docEmphasis">C++ for Java Programmers</span> by Mark Allen Weiss
(Prentice Hall, 2003).</p>
<a name="app04lev2sec1"></a>
<h4 id="title-ID0EWVPM" class="docSection2Title">Primitive Data
Types</h4>

<p class="docText"><a name="similar to"></a>The primitive data
types offered by the C++ language are similar to those found in
Java or C#. <a class="docLink" href="#app04fig02">Figure
D.2</a><a name="definitions on"></a> lists C++'s primitive types
and their definitions on the platforms supported by Qt 4.</p>
<a name="app04fig02"></a>
<h5 class="docTableTitle">Figure D.2. Primitive C++ types</h5>

<table cellspacing="0" class="allBorders" border="1">
<colgroup align="left" span="2">
<col width="100">
<col width="300">
</colgroup>

<thead>
<tr>
<th scope="col" class="docTableCell thead" align="center" valign=
"top" style="background-color:#E6E6E6">C++ Type</th>
<th scope="col" class="docTableCell thead" align="center" valign=
"top" style="background-color:#E6E6E6">Description</th>
</tr>
</thead>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>bool</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">Boolean value</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>char</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">8-bit integer</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>short</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">16-bit integer</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>int</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">32-bit integer</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>long</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">32-bit or 64-bit integer</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>long
long</tt><sup class="docFootnote"><a class="docLink" href=
"#app04fn01">[*]</a></sup>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">64-bit integer</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>float</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">32-bit floating-point value (IEEE 754)</span>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>double</tt>
</td>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">64-bit floating-point value (IEEE 754)</span>
</td>
</tr>
</table>
<br>

<blockquote>
<p class="docFootnote"><sup><a name="app04fn01">[*]</a></sup>
Microsoft calls the non-standard (but due to be standardized)
<tt>long long</tt> type <tt>__int64</tt>. In Qt programs,
<tt>qlonglong</tt><a name="Qt platforms"></a> is available as an
alternative that works on all Qt platforms.</p>
</blockquote>

<p class="docText">By default, the <tt>short</tt>, <tt>int</tt>,
<tt>long</tt>, and <tt>long long</tt><a name="hold negative"></a>
data types are signed, meaning that they can hold negative values
as well as positive values. If we only need to store nonnegative
integers, we can put the <tt>unsigned</tt> keyword in front of the
type. Whereas a <tt>short</tt> can hold any value between -32768
and +32767, an <tt>unsigned</tt> <a name="iddle1040"></a><a name=
"iddle1316"></a><a name="iddle1450"></a><a name=
"iddle1527"></a><a name="iddle2404"></a><a name=
"iddle3253"></a><a name="iddle3595"></a><a name=
"iddle4401"></a><a name="iddle4568"></a><a name=
"iddle6744"></a><a name="iddle7598"></a><a name=
"iddle8377"></a><tt>short</tt> goes from 0 to 65535. The
right-shift operator <tt>&gt;&gt;</tt> has unsigned ("fill with
0s") semantics if one of the operands is unsigned.</p>

<p class="docText">The <tt>bool</tt> type can take the values
<tt>true</tt> and <tt>false</tt>. In addition, numeric types can be
used where a <tt>bool</tt> is expected, with the rule that 0 means
<tt>false</tt> and any non-zero value means <tt>true</tt>.</p>

<p class="docText">The <tt>char</tt><a name="used as"></a> type is
used for storing ASCII characters and 8-bit integers (bytes). When
used as an integer, it can be signed or unsigned, depending on the
platform. The types <tt>signed char</tt> and <tt>unsigned
char</tt><a name="unambiguous alternatives"></a> are available as
unambiguous alternatives to <tt>char</tt><a name="a"></a>. Qt
provides a <tt>QChar</tt><a name="type that"></a> type that stores
16-bit Unicode characters.</p>

<p class="docText"><a name="types are"></a>Instances of built-in
types are not initialized by default. When we create an
<tt>int</tt><a name="value could"></a> variable, its value could
conceivably be 0, but could just as likely be -209486515.
Fortunately, most compilers warn us when we attempt to read the
contents of an uninitialized variable, and we can use tools such as
Rational PurifyPlus and Valgrind to detect uninitialized memory
accesses and other memory-related problems at run-time.</p>

<p class="docText">In memory, the numeric types (except
<tt>long</tt><a name="but their"></a>) have identical sizes on the
different platforms supported by Qt, but their representation
varies depending on the system's byte order. On big-endian
architectures (such as PowerPC and SPARC), the 32-bit value
<tt>0x12345678</tt><a name="bytes"></a> is stored as the four bytes
<tt>0x12 0x34 0x56 0x78</tt><a name="This makes"></a>, whereas on
little-endian architectures (such as Intel x86), the byte sequence
is reversed. This makes a difference in programs that copy memory
areas onto disk or that send binary data over the network. Qt's
<tt>QDataStream</tt> class, presented in <a class="docLink" href=
"ch12.html#ch12">Chapter 12</a><a name="in a"></a>, can be used to
store binary data in a platform-independent way.</p>
<a name="app04lev2sec2"></a>
<h4 id="title-ID0EQAAO" class="docSection2Title">Class
Definitions</h4>

<p class="docText"><a name="iddle1592"></a><a name=
"iddle1775"></a><a name="iddle1780"></a><a name=
"iddle1789"></a><a name="iddle2060"></a><a name=
"iddle2877"></a><a name="iddle3222"></a><a name=
"iddle4369"></a><a name="iddle4371"></a><a name=
"iddle4453"></a><a name="iddle4551"></a><a name=
"iddle4554"></a><a name="iddle4560"></a><a name=
"iddle7799"></a><a name="but there"></a>Class definitions in C++
are similar to those in Java and C#, but there are several
differences to be aware of. We will study these differences using a
series of examples. Let's start with a class that represent an
(<span class="docEmphasis">x</span>, <span class=
"docEmphasis">y</span>) coordinate pair:</p>

<div class="docText">
<div class="codeSegmentsExpansionLinks">Code View:</div>

<pre class="">
#ifndef POINT2D_H
#define POINT2D_H

class Point2D
{
public:
    Point2D() {
        xVal = 0;
        yVal = 0;
    }
    Point2D(double x, double y) {
        xVal = x;
        yVal = y;
    }

    void setX(double x) { xVal = x; }
    void setY(double y) { yVal = y; }
    double x() const { return xVal; }
    double y() const { return yVal; }

private:
    double xVal;
    double yVal;
};

#endif

                                          
</pre>
</div>
<br>

<p class="docText"><a name="definition would"></a>The preceding
class definition would appear in a header file, typically called
<tt>point2d.h</tt><a name="exhibits the"></a>. The example exhibits
the following C++ idiosyncrasies:</p>

<ul>
<li>
<p class="docList"><a name="A class"></a>A class definition is
divided into public, protected, and private sections, and ends with
a semicolon. If no section is specified, the default is private.
(For compatibility with C, C++ provides a <tt>struct</tt><a name=
"is identical"></a> keyword that is identical to
<tt>class</tt><a name="that the"></a> except that the default is
public if no section is specified.)</p>
</li>

<li>
<p class="docList"><a name="and one"></a>The class has two
constructors (one that has no parameters and one that has two). If
we declared no constructor, C++ would automatically supply one with
no parameters and an empty body.</p>
</li>

<li>
<p class="docList">The getter functions <tt>x()</tt> and
<tt>y()</tt><a name="means that"></a> are declared to be const.
This means that they don't (and can't) modify the member variables
or call non-const member functions (such as <tt>setX()</tt> and
<tt>setY()</tt>).</p>
</li>
</ul>

<p class="docText"><a name="class definition"></a>The preceding
functions were implemented inline, as part of the class definition.
An alternative is to provide only function prototypes in the header
file and to implement the functions in a <tt>.cpp</tt><a name=
"like this"></a> file. Using this approach, the header file would
look like this:</p>

<div class="docText">
<pre>
#ifndef POINT2D_H
#define POINT2D_H

class Point2D
{
public:
    Point2D();
    Point2D(double x, double y);

    void setX(double x);
    void setY(double y);
    double x() const;
    double y() const;

private:
    double xVal;
    double yVal;
};

#endif
</pre>
</div>
<br>

<p class="docText">The functions would then be implemented in
<tt>point2d.cpp</tt>:</p>

<div class="docText">
<div class="codeSegmentsExpansionLinks">Code View:</div>

<pre class="">
#include "point2d.h"

Point2D::Point2D()
{
    xVal = 0.0;
    yVal = 0.0;
}

Point2D::Point2D(double x, double y)
{
    xVal = x;
    yVal = y;
}

void Point2D::setX(double x)
{
    xVal = x;
}

void Point2D::setY(double y)
{
    yVal = y;
}

double Point2D::x() const
{
    return xVal;
}

double Point2D::y() const
{
    return yVal;
}

                                          
</pre>
</div>
<br>

<p class="docText">We start by including <tt>point2d.h</tt><a name=
"parse member"></a> because the compiler needs the class definition
before it can parse member function implementations. Then we
implement <a name="iddle1009"></a><a name="iddle1018"></a><a name=
"iddle1790"></a><a name="iddle2061"></a><a name=
"iddle3567"></a><a name="iddle3994"></a><a name=
"iddle4372"></a><a name="iddle4384"></a><a name=
"iddle7411"></a><a name="iddle7820"></a><a name=
"iddle8319"></a><a name="function name"></a>the functions,
prefixing the function name with the class name using the
<tt>::</tt> operator.</p>

<p class="docText"><a name="seen how"></a>We have seen how to
implement a function inline and now how to implement it in a
<tt>.cpp</tt><a name="The two"></a> file. The two approaches are
semantically equivalent, but when we call a function that is
declared inline, most compilers simply expand the function's body
instead of generating an actual function call. This normally leads
to faster code, but might increase the size of your application.
For this reason, only very short functions should be implemented
inline; longer functions should always be implemented in a
<tt>.cpp</tt><a name="we forget"></a> file. In addition, if we
forget to implement a function and try to call it, the linker will
complain about an unresolved symbol.</p>

<p class="docText"><a name="to use"></a>Now, let's try to use the
class.</p>

<div class="docText">
<pre>
#include "point2d.h"

int main()
{
    Point2D alpha;
    Point2D beta(0.666, 0.875);

    alpha.setX(beta.y());
    beta.setY(alpha.x());

    return 0;
}
</pre>
</div>
<br>

<p class="docText"><a name="without using"></a>In C++, variables of
any types can be declared directly without using
<tt>new</tt><a name="using the"></a>. The first variable is
initialized using the default <tt>Point2D</tt><a name=
"initialized using"></a> constructor (the constructor that has no
parameters). The second variable is initialized using the second
constructor. Access to an object's member is performed using the
<tt>.</tt> (dot) operator.</p>

<p class="docText"><a name="types such"></a>Variables declared this
way behave like Java/C# primitive types such as <tt>int</tt> and
<tt>double</tt><a name="variable are"></a>. For example, when we
use the assignment operator, the contents of the variable are
copied—not just a reference to an object. And if we modify a
variable later on, any other variables that were assigned from it
are left unchanged.</p>

<p class="docText"><a name="inheritance and"></a>As an
object-oriented language, C++ supports inheritance and
polymorphism. To illustrate how it works, we will review the
example of a <tt>Shape</tt><a name="class and"></a> abstract base
class and a subclass called <tt>Circle</tt><a name=
"start with"></a>. Let's start with the base class:</p>

<div class="docText">
<pre>
#ifndef SHAPE_H
#define SHAPE_H

#include "point2d.h"

class Shape
{
public:
    Shape(Point2D center) { myCenter = center; }

    virtual void draw() = 0;

protected:
    Point2D myCenter;
};

#endif
</pre>
</div>
<br>

<p class="docText"><a name="iddle1565"></a><a name=
"iddle2235"></a><a name="iddle3260"></a><a name=
"iddle4077"></a><a name="iddle4082"></a><a name=
"iddle4452"></a><a name="iddle4550"></a><a name=
"iddle4559"></a><a name="iddle4567"></a><a name=
"iddle8459"></a><a name="appears in"></a>The definition appears in
a header file called <tt>shape.h</tt><a name="the class"></a>.
Since the class definition refers to the <tt>Point2D</tt> class, we
include <tt>point2d.h</tt>.</p>

<p class="docText">The <tt>Shape</tt> class has no base class.
Unlike Java and C#, C++ doesn't provide an <tt>Object</tt> class
from which all classes are implicitly derived. Qt provides
<tt>QObject</tt> as a natural base class for all kinds of
objects.</p>

<p class="docText">The <tt>draw()</tt> function declaration has two
interesting features: It contains the <tt>virtual</tt> keyword, and
it ends with <tt>= 0</tt>. The <tt>virtual</tt><a name=
"Like in"></a> keyword indicates that the function may be
reimplemented in subclasses. Like in C#, C++ member functions
aren't reimplementable by default. The bizarre <tt>= 0</tt><a name=
"is a"></a> syntax indicates that the function is a <span class=
"docEmphasis">pure virtual function</span><a name=
"be implemented"></a>—a function that has no default implementation
and that must be implemented in subclasses. The concept of an
"interface" in Java and C# maps to a class with only pure virtual
functions in C++.</p>

<p class="docText">Here's the definition of the <tt>Circle</tt>
subclass:</p>

<div class="docText">
<pre>
#ifndef CIRCLE_H
#define CIRCLE_H

#include "shape.h"

class Circle : public Shape
{
public:
    Circle(Point2D center, double radius = 0.5)
        : Shape(center) {
        myRadius = radius;
    }

    void draw() {
        // do something here
    }

private:
    double myRadius;
};

#endif
</pre>
</div>
<br>

<p class="docText">The <tt>Circle</tt> class is publicly derived
from <tt>Shape</tt>, meaning that all public members of
<tt>Shape</tt> remain public in <tt>Circle</tt><a name=
"the access"></a>. C++ also supports protected and private
inheritance, which restrict the access of the base class's public
and protected members.</p>

<p class="docText"><a name="takes the"></a>The constructor takes
two parameters. The second parameter is optional and takes the
value 0.5 if not specified. The constructor passes the
<tt>center</tt><a name="base class"></a> parameter to the base
class's constructor using a special syntax between the function
signature and the function body. In the body, we initialize the
<tt>myRadius</tt> member <a name="iddle1019"></a><a name=
"iddle1290"></a><a name="iddle1566"></a><a name=
"iddle2232"></a><a name="iddle2233"></a><a name=
"iddle2236"></a><a name="iddle3469"></a><a name=
"iddle3950"></a><a name="iddle4206"></a><a name=
"iddle7731"></a><a name="iddle7889"></a><a name=
"iddle8241"></a><a name="also have"></a>variable. We could also
have initialized the variable on the same line as the base class
constructor initialization:</p>

<div class="docText">
<pre>
    Circle(Point2D center, double radius = 0.5)
        : Shape(center), myRadius(radius) { }
</pre>
</div>
<br>

<p class="docText"><a name="On the"></a>On the other hand, C++
doesn't allow us to initialize a member variable in the class
definition, so the following code is wrong:</p>

<div class="docText">
<pre>
// WON'T COMPILE
private:
    double myRadius = 0.5;
};
</pre>
</div>
<br>

<p class="docText">The <tt>draw()</tt><a name="the same"></a>
function has the same signature as the virtual
<tt>draw()</tt><a name="declared in"></a> function declared in
<tt>Shape</tt><a name="polymorphically when"></a>. It is a
reimplementation and it will be invoked polymorphically when
<tt>draw()</tt> is called on a <tt>Circle</tt> instance through a
<tt>Shape</tt> reference or pointer. C++ has no
<tt>override</tt><a name="have a"></a> keyword like in C#. Nor does
C++ have a <tt>super</tt> or <tt>base</tt><a name="to call"></a>
keyword that refers to the base class. If we need to call the base
implementation of a function, we can prefix the function name with
the base class name and the <tt>::</tt> operator. For example:</p>

<div class="docText">
<pre>
class LabeledCircle : public Circle
{
public:
    void draw() {
        Circle::draw();
        drawLabel();
    }
    ...
};
</pre>
</div>
<br>

<p class="docText"><a name="be derived"></a>C++ supports multiple
inheritance, meaning that a class can be derived from several
classes at the same time. The syntax is as follows:</p>

<div class="docText">
<pre>
class <span class=
"docEmphasis">DerivedClass</span> : public <span class=
"docEmphasis">BaseClass1</span>, public <span class=
"docEmphasis">BaseClass2</span>, ...,
                     public <span class=
"docEmphasis">BaseClassN</span>
{
    ...
};
</pre>
</div>
<br>

<p class="docText"><a name="with instances"></a>By default,
functions and variables declared in a class are associated with
instances of that class. We can also declare static member
functions and static member variables, which can be used without an
instance. For example:</p>

<div class="docText">
<pre>
#ifndef TRUCK_H
#define TRUCK_H

class Truck
{
public:
    Truck() { ++counter; }
    ~Truck() { --counter; }
    static int instanceCount() { return counter; }

private:
    static int counter;
};

#endif
</pre>
</div>
<br>

<p class="docText"><a name="iddle2114"></a><a name=
"iddle2745"></a><a name="iddle3568"></a><a name=
"iddle4373"></a><a name="iddle6820"></a><a name=
"iddle7725"></a><a name="iddle8320"></a><a name="variable"></a>The
static member variable <tt>counter</tt><a name="of how"></a> keeps
track of how many <tt>Truck</tt><a name="instances exist"></a>
instances exist at any time. The <tt>Truck</tt><a name=
"The destructor"></a> constructor increments it. The destructor,
recognizable by the tilde (<tt>~</tt><a name="In C"></a>) prefix,
decrements it. In C++, the destructor is automatically invoked when
a statically allocated variable goes out of scope or when a
variable allocated using <tt>new</tt> is deleted. This is similar
to the <tt>finalize()</tt><a name="being called"></a> method in
Java, except that we can rely on it being called at a specific
point in time.</p>

<p class="docText"><a name="a single"></a>A static member variable
has a single existence in a class: Such variables are "class
variables" rather than "instance variables". Each static member
variable must be defined in a <tt>.cpp</tt> file (but without
repeating the <tt>static</tt> keyword). For example:</p>

<div class="docText">
<pre>
#include "truck.h"

int Truck::counter = 0;
</pre>
</div>
<br>

<p class="docText"><a name="at link"></a>Failing to do this would
result in an "unresolved symbol" error at link time. The
<tt>instanceCount()</tt><a name="the class"></a> static function
can be accessed from outside the class, prefixed by the class name.
For example:</p>

<div class="docText">
<pre>
#include &lt;iostream&gt;

#include "truck.h"

int main()
{
    Truck truck1;
    Truck truck2;

    std::cout &lt;&lt; Truck::instanceCount() &lt;&lt; " equals 2" &lt;&lt; std::endl;

    return 0;
}
</pre>
</div>
<br>
<a name="app04lev2sec3"></a>
<h4 id="title-ID0EIXAO" class="docSection2Title">Pointers</h4>

<p class="docText">A <span class=
"docEmphasis">pointer</span><a name="an object"></a> in C++ is a
variable that stores the memory address of an object (instead of
storing the object directly). Java and C# have a similar concept,
that of a "reference", but the syntax is different. We will start
by studying a contrived example that illustrates pointers in
action:</p>

<div class="docText">
<pre>
 <span class="docEmphRomanAlt">1</span> #include "point2d.h"

 <span class="docEmphRomanAlt">2</span> int main()
 <span class="docEmphRomanAlt">3</span> {
 <span class="docEmphRomanAlt">4</span>     Point2D alpha;
 <span class="docEmphRomanAlt">5</span>     Point2D beta;
 <span class="docEmphRomanAlt">6</span>     Point2D *ptr;

 <span class="docEmphRomanAlt">7</span>     ptr = &amp;alpha;
 <span class="docEmphRomanAlt">8</span>     ptr-&gt;setX(1.0);
 <span class="docEmphRomanAlt">9</span>     ptr-&gt;setY(2.5);

<span class="docEmphRomanAlt">10</span>     ptr = &amp;beta;
<span class="docEmphRomanAlt">11</span>     ptr-&gt;setX(4.0);
<span class="docEmphRomanAlt">12</span>     ptr-&gt;setY(4.5);

<span class="docEmphRomanAlt">13</span>     ptr = 0;

<span class="docEmphRomanAlt">14</span>     return 0;
<span class="docEmphRomanAlt">15</span> }
</pre>
</div>
<br>

<p class="docText"><a name="iddle1006"></a><a name=
"iddle1007"></a><a name="iddle1010"></a><a name=
"iddle1415"></a><a name="iddle2889"></a><a name=
"iddle3611"></a><a name="iddle3780"></a><a name=
"iddle3786"></a><a name="iddle3995"></a><a name=
"iddle4069"></a><a name="iddle7064"></a><a name=
"iddle7684"></a><a name="on the"></a>The example relies on the
<tt>Point2D</tt><a name="the previous"></a> class from the previous
subsection. Lines 4 and 5 define two objects of type
<tt>Point2D</tt><a name="These objects"></a>. These objects are
initialized to (0, 0) by the default <tt>Point2D</tt>
constructor.</p>

<p class="docText"><a name="a pointer"></a>Line 6 defines a pointer
to a <tt>Point2D</tt><a name="syntax for"></a> object. The syntax
for pointers uses an asterisk in front of the variable name. Since
we did not initialize the pointer, it contains a random memory
address. This is solved on line 7 by assigning <tt>alpha</tt>'s
address to the pointer. The unary <tt>&amp;</tt><a name=
"is typically"></a> operator returns the memory address of an
object. An address is typically a 32-bit or a 64-bit integer value
specifying the offset of an object in memory.</p>

<p class="docText"><a name="the"></a>On lines 8 and 9, we access
the <tt>alpha</tt> object through the <tt>ptr</tt> pointer. Because
<tt>ptr</tt><a name="the"></a> is a pointer and not an object, we
must use the <tt>-&gt;</tt> (arrow) operator instead of the
<tt>.</tt> (dot) operator.</p>

<p class="docText">On line 10, we assign <tt>beta</tt><a name=
"we perform"></a>'s address to the pointer. From then on, any
operation we perform through the pointer will affect the
<tt>beta</tt> object.</p>

<p class="docText"><a name="keyword for"></a>Line 13 sets the
pointer to be a null pointer. C++ has no keyword for representing a
pointer that does not point to an object; instead, we use the value
0 (or the symbolic constant <tt>NULL</tt><a name="Trying to"></a>,
which expands to 0). Trying to use a null pointer results in a
crash with an error message such as "Segmentation fault", "General
protection fault", or "Bus error". Using a debugger, we can find
out which line of code caused the crash.</p>

<p class="docText"><a name="end of"></a>At the end of the function,
the <tt>alpha</tt><a name="object holds"></a> object holds the
coordinate pair (1.0, 2.5), whereas <tt>beta</tt> holds (4.0,
4.5).</p>

<p class="docText"><a name="often used"></a>Pointers are often used
to store objects allocated dynamically using <tt>new</tt><a name=
"we say"></a>. In C++ jargon, we say that these objects are
allocated on the "heap", whereas local variables (variables defined
inside a function) are stored on the "stack".</p>

<p class="docText">Here's a code snippet that illustrates dynamic
memory allocation using <tt>new</tt>:</p>

<div class="docText">
<pre>
#include "point2d.h"

int main()
{
    Point2D *point = new Point2D;
    point-&gt;setX(1.0);
    point-&gt;setY(2.5);
    delete point;

    return 0;
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1776"></a><a name=
"iddle2088"></a><a name="iddle2881"></a><a name=
"iddle3996"></a><a name="iddle4118"></a><a name=
"iddle5439"></a><a name="iddle5600"></a><a name=
"iddle7550"></a><a name="iddle7685"></a>The <tt>new</tt><a name=
"We store"></a> operator returns the memory address of a newly
allocated object. We store the address in a pointer variable and
access the object through that pointer. When we are done with the
object, we release its memory using the <tt>delete</tt><a name=
"garbage collector"></a> operator. Unlike Java and C#, C++ has no
garbage collector; dynamically allocated objects must be explicitly
released using <tt>delete</tt> when we don't need them anymore.
<a class="docLink" href="ch02.html#ch02">Chapter 2</a> describes
Qt's parent–child mechanism, which greatly simplifies memory
management in C++ programs.</p>

<p class="docText">If we forget to call <tt>delete</tt><a name=
"would not"></a>, the memory is kept around until the program
finishes. This would not be an issue in the preceding example,
because we allocate only one object, but in a program that
allocates new objects all the time, this could cause the program to
keep allocating memory until the machine's memory is exhausted.
Once an object is deleted, the pointer variable still holds the
address of the object. Such a pointer is a "dangling pointer" and
should not be used to access the object. Qt provides a "smart"
pointer, <tt>QPointer&lt;T&gt;</tt>, that automatically sets itself
to 0 if the <tt>QObject</tt> it points to is deleted.</p>

<p class="docText"><a name="constructor and"></a>In the preceding
example, we invoked the default constructor and called
<tt>setX()</tt> and <tt>setY()</tt> to initialize the object. We
could have used the two-parameter constructor instead:</p>

<div class="docText">
<pre>
Point2D *point = new Point2D(1.0, 2.5);
</pre>
</div>
<br>

<p class="docText">The example didn't require the use of
<tt>new</tt> and <tt>delete</tt><a name="the stack"></a>. We could
just as well have allocated the object on the stack as follows:</p>

<div class="docText">
<pre>
Point2D point;
point.setX(1.0);
point.setY(2.5);
</pre>
</div>
<br>

<p class="docText"><a name="this are"></a>Objects allocated like
this are automatically freed at the end of the block in which they
appear.</p>

<p class="docText"><a name="intend to"></a>If we don't intend to
modify the object through the pointer, we can declare the pointer
const. For example:</p>

<div class="docText">
<pre>
const Point2D *ptr = new Point2D(1.0, 2.5);
double x = ptr-&gt;x();
double y = ptr-&gt;y();

// WON'T COMPILE
ptr-&gt;setX(4.0);
*ptr = Point2D(4.0, 4.5);
</pre>
</div>
<br>

<p class="docText"><a name="The"></a>The <tt>ptr</tt><a name=
"can be"></a> const pointer can be used only to call const member
functions such as <tt>x()</tt> and <tt>y()</tt><a name=
"is good"></a>. It is good style to declare pointers const when we
don't intend to modify the object using them. Furthermore, if the
object itself is const, we have <a name="iddle1008"></a><a name=
"iddle1011"></a><a name="iddle2744"></a><a name=
"iddle3781"></a><a name="iddle6821"></a><a name="store its"></a>no
choice but to use a const pointer to store its address. The use of
<tt>const</tt><a name="that can"></a> provides information to the
compiler that can lead to early bug detection and performance
gains. C# has a <tt>const</tt><a name="closest Java"></a> keyword
that is very similar to that of C++. The closest Java equivalent is
<tt>final</tt><a name="from calling"></a>, but it only protects
variables from assignment, not from calling "non-const" member
functions on it.</p>

<p class="docText"><a name="In an"></a>Pointers can be used with
built-in types as well as with classes. In an expression, the unary
<tt>*</tt><a name="value of"></a> operator returns the value of the
object associated with the pointer. For example:</p>

<div class="docText">
<pre>
int i = 10;
int j = 20;

int *p = &amp;i;
int *q = &amp;j;

std::cout &lt;&lt; *p &lt;&lt; " equals 10" &lt;&lt; std::endl;
std::cout &lt;&lt; *q &lt;&lt; " equals 20" &lt;&lt; std::endl;

*p = 40;

std::cout &lt;&lt; i &lt;&lt; " equals 40" &lt;&lt; std::endl;

p = q;
*p = 100;

std::cout &lt;&lt; i &lt;&lt; " equals 40" &lt;&lt; std::endl;
std::cout &lt;&lt; j &lt;&lt; " equals 100" &lt;&lt; std::endl;
</pre>
</div>
<br>

<p class="docText">The <tt>-&gt;</tt><a name="be used"></a>
operator, which can be used to access an object's members through a
pointer, is pure syntactic sugar. Instead of
<tt>ptr-&gt;member</tt><a name="we can"></a>, we can also write
<tt>(*ptr).member</tt><a name="are necessary"></a>. The parentheses
are necessary because the <tt>.</tt><a name="has precedence"></a>
(dot) operator has precedence over the unary <tt>*</tt>
operator.</p>

<p class="docText"><a name="the extent"></a>Pointers had a poor
reputation in C and C++, to the extent that Java is often
advertised as having no pointers. In reality, C++ pointers are
conceptually similar to Java and C# references except that we can
use pointers to iterate through memory, as we will see later in
this section. Furthermore, the inclusion of "copy on write"
container classes in Qt, along with C++'s ability to instantiate
any class on the stack, means that we can often avoid pointers.</p>
<a name="app04lev2sec4"></a>
<h4 id="title-ID0ECFBO" class="docSection2Title">References</h4>

<p class="docText"><a name="the concept"></a>In addition to
pointers, C++ also supports the concept of a "reference". Like a
pointer, a C++ reference stores the address of an object. Here are
the main differences:</p>

<ul>
<li>
<p class="docList">References are declared using <tt>&amp;</tt>
instead of <tt>*</tt>.</p>
</li>

<li>
<p class="docList">The reference must be initialized and can't be
reassigned later.</p>
</li>

<li>
<p class="docList"><a name="is no"></a>The object associated with a
reference is directly accessible; there is no special syntax such
as <tt>*</tt> or <tt>-&gt;</tt>.</p>
</li>

<li>
<p class="docList">A reference cannot be null.</p>
</li>
</ul>

<p class="docText"><a name="iddle3753"></a><a name=
"most types"></a>References are generally used when declaring
parameters. For most types, C++ uses call-by-value as its default
parameter-passing mechanism, meaning that when an argument is
passed to a function, the function receives a brand new copy of the
object. Here's the definition of a function that receives its
parameters through call-by-value:</p>

<div class="docText">
<pre>
#include &lt;cstdlib&gt;

double manhattanDistance(Point2D a, Point2D b)
{
    return std::abs(b.x() - a.x()) + std::abs(b.y() - a.y());
}
</pre>
</div>
<br>

<p class="docText">We would then invoke the function as
follows:</p>

<div class="docText">
<pre>
Point2D broadway(12.5, 40.0);
Point2D harlem(77.5, 50.0);
double distance = manhattanDistance(broadway, harlem);
</pre>
</div>
<br>

<p class="docText"><a name="as pointers"></a>C programmers avoid
needless copy operations by declaring their parameters as pointers
instead of as values:</p>

<div class="docText">
<pre>
double manhattanDistance(const Point2D *ap, const Point2D *bp)
{
    return std::abs(bp-&gt;x() - ap-&gt;x()) + std::abs(bp-&gt;y() - ap-&gt;y());
}
</pre>
</div>
<br>

<p class="docText"><a name="pass addresses"></a>They must then pass
addresses instead of values when calling the function:</p>

<div class="docText">
<pre>
double distance = manhattanDistance(&amp;broadway, &amp;harlem);
</pre>
</div>
<br>

<p class="docText"><a name="to make"></a>C++ introduced references
to make the syntax less cumbersome and to prevent the caller from
passing a null pointer. If we use references instead of pointers,
the function looks like this:</p>

<div class="docText">
<pre>
double manhattanDistance(const Point2D &amp;a, const Point2D &amp;b)
{
    return std::abs(b.x() - a.x()) + std::abs(b.y() - a.y());
}
</pre>
</div>
<br>

<p class="docText"><a name="The declaration"></a>The declaration of
a reference is similar to that of a pointer, with <tt>&amp;</tt>
instead of <tt>*</tt><a name="we actually"></a>. But when we
actually use the reference, we can forget that it is a memory
address and treat it like an ordinary variable. In addition,
calling a function that takes references as arguments doesn't
require any special care (no <tt>&amp;</tt> operator).</p>

<p class="docText"><a name="in all"></a>All in all, by replacing
<tt>Point2D</tt> with <tt>const Point2D &amp;</tt><a name=
"function call"></a> in the parameter list, we reduced the overhead
of the function call: Instead of copying 256 bits (the size of four
<tt>double</tt><a name="on the"></a>s), we copy only 64 or 128
bits, depending on the target platform's pointer size.</p>

<p class="docText"><a name="modifying the"></a>The previous example
used const references, preventing the function from modifying the
objects associated with the references. When this kind of side
effect is desired, we can pass a non-const reference or pointer.
For example:</p>

<div class="docText">
<pre>
void transpose(Point2D &amp;point)
{
    double oldX = point.x();
    point.setX(point.y());
    point.setY(oldX);
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1221"></a><a name=
"iddle4374"></a><a name="iddle8211"></a><a name="we need"></a>In
some cases, we have a reference and we need to call a function that
takes a pointer, or vice versa. To convert a reference to a
pointer, we can simply use the unary <tt>&amp;</tt> operator:</p>

<div class="docText">
<pre>
Point2D point;
Point2D &amp;ref = point;
Point2D *ptr = &amp;ref;
</pre>
</div>
<br>

<p class="docText">To convert a pointer to a reference, there is
the unary <tt>*</tt> operator:</p>

<div class="docText">
<pre>
Point2D point;
Point2D *ptr = &amp;point;
Point2D &amp;ref = *ptr;
</pre>
</div>
<br>

<p class="docText"><a name="they can"></a>References and pointers
are represented the same way in memory, and they can often be used
interchangeably, which begs the question of when to use which. On
the one hand, references have a more convenient syntax; on the
other hand, pointers can be reassigned at any time to point to
another object, they can hold a null value, and their more explicit
syntax is often a blessing in disguise. For these reasons, pointers
tend to prevail, with references used almost exclusively for
declaring function parameters, in conjunction with
<tt>const</tt>.</p>
<a name="app04lev2sec5"></a>
<h4 id="title-ID0EPKBO" class="docSection2Title">Arrays</h4>

<p class="docText"><a name="declared by"></a>Arrays in C++ are
declared by specifying the number of items in the array within
brackets in the variable declaration <span class=
"docEmphasis">after</span><a name="arrays are"></a> the variable
name. Two-dimensional arrays are possible using an array of arrays.
Here's the definition of a one-dimensional array containing ten
items of type <tt>int</tt>:</p>

<div class="docText">
<pre>
int fibonacci[10];
</pre>
</div>
<br>

<p class="docText"><a name="The items"></a>The items are accessible
as <tt>fibonacci[0]</tt>, <tt>fibonacci[1]</tt>, ...,
<tt>fibonacci[9]</tt><a name="want to"></a>. Often we want to
initialize the array as we define it:</p>

<div class="docText">
<pre>
int fibonacci[10] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
</pre>
</div>
<br>

<p class="docText"><a name="such cases"></a>In such cases, we can
then omit the array size, since the compiler can deduce it from the
number of initializers:</p>

<div class="docText">
<pre>
int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
</pre>
</div>
<br>

<p class="docText">Static initialization also works for complex
types, such as <tt>Point2D</tt>:</p>

<div class="docText">
<pre>
Point2D triangle[] = {
    Point2D(0.0, 0.0), Point2D(1.0, 0.0), Point2D(0.5, 0.866)
};
</pre>
</div>
<br>

<p class="docText"><a name="iddle1777"></a><a name=
"iddle2424"></a><a name="iddle4375"></a><a name=
"iddle7512"></a><a name="later on"></a>If we have no intention of
altering the array later on, we can make it const:</p>

<div class="docText">
<pre>
const int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
</pre>
</div>
<br>

<p class="docText"><a name="items an"></a>To find out how many
items an array contains, we can use the <tt>sizeof()</tt> operator
as follows:</p>

<div class="docText">
<pre>
int n = sizeof(fibonacci) / sizeof(fibonacci[0]);
</pre>
</div>
<br>

<p class="docText">The <tt>sizeof()</tt><a name="number of"></a>
operator returns the size of its argument in bytes. The number of
items in an array is its size in bytes divided by the size of one
of its items. Because this is cumbersome to type, a common
alternative is to declare a constant and to use it for defining the
array:</p>

<div class="docText">
<pre>
enum { NFibonacci = 10 };

const int fibonacci[NFibonacci] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
</pre>
</div>
<br>

<p class="docText"><a name="the constant"></a>It would have been
tempting to declare the constant as a <tt>const int</tt><a name=
"We will"></a> variable. Unfortunately, some compilers have issues
with const variables as array size specifiers. We will explain the
<tt>enum</tt><a name="this appendix"></a> keyword later in this
appendix.</p>

<p class="docText"><a name="an array"></a>Iterating through an
array is normally done using an integer. For example:</p>

<div class="docText">
<pre>
for (int i = 0; i &lt; NFibonacci; ++i)
    std::cout &lt;&lt; fibonacci[i] &lt;&lt; std::endl;
</pre>
</div>
<br>

<p class="docText"><a name="It is"></a>It is also possible to
traverse the array using a pointer:</p>

<div class="docText">
<pre>
const int *ptr = &amp;fibonacci[0];
while (ptr != &amp;fibonacci[10]) {
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
    ++ptr;
}
</pre>
</div>
<br>

<p class="docText"><a name="the pointer"></a>We initialize the
pointer with the address of the first item and loop until we reach
the "one past the last" item (the "eleventh" item,
<tt>fibonacci[10]</tt><a name="each iteration"></a>). At each
iteration, the <tt>++</tt> operator advances the pointer to the
next item.</p>

<p class="docText">Instead of <tt>&amp;fibonacci[0]</tt>, we could
also have written <tt>fibonacci</tt><a name="alone is"></a>. This
is because the name of an array used alone is automatically
converted into a pointer to the first item in the array. Similarly,
we could substitute <tt>fibonacci + 10</tt> for
<tt>&amp;fibonacci[10]</tt><a name="around as"></a>. This works the
other way around as well: We can retrieve the contents of the
current item using either <tt>*ptr</tt> or <tt>ptr[0]</tt> and
could access the next item using <tt>*(ptr + 1)</tt> or
<tt>ptr[1]</tt>. This principle is sometimes called "equivalence of
pointers and arrays".</p>

<p class="docText"><a name="does not"></a>To prevent what it
considers to be a gratuitous inefficiency, C++ does not let us pass
arrays to functions by value. Instead, they must be passed by
address. For example:</p>

<div class="docText">
<pre>
#include &lt;iostream&gt;

void printIntegerTable(const int *table, int size)
{
    for (int i = 0; i &lt; size; ++i)
        std::cout &lt;&lt; table[i] &lt;&lt; std::endl;
}

int main()
{
    const int fibonacci[10] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
    printIntegerTable(fibonacci, 10);
    return 0;
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1031"></a><a name=
"iddle1153"></a><a name="iddle1836"></a><a name=
"iddle2089"></a><a name="iddle3779"></a><a name=
"iddle3999"></a><a name="iddle7756"></a><a name=
"iddle7764"></a><a name="iddle7958"></a><a name=
"iddle8416"></a><a name="iddle8419"></a><a name=
"we want"></a>Ironically, although C++ doesn't give us any choice
about whether we want to pass an array by address or by value, it
gives us some freedom in the <span class=
"docEmphasis">syntax</span> used to declare the parameter type.
Instead of <tt>const int *table</tt>, we could also have written
<tt>const int table[]</tt> to declare a
pointer-to-constant-<tt>int</tt> parameter. Similarly, the
<tt>argv</tt> parameter to <tt>main()</tt> can be declared as
either <tt>char *argv[]</tt> or <tt>char **argv</tt>.</p>

<p class="docText"><a name="loop through"></a>To copy an array into
another array, one approach is to loop through the array:</p>

<div class="docText">
<pre>
const int fibonacci[NFibonacci] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };
int temp[NFibonacci];

for (int i = 0; i &lt; NFibonacci; ++i)
    temp[i] = fibonacci[i];
</pre>
</div>
<br>

<p class="docText"><a name="types such"></a>For basic data types
such as <tt>int</tt><a name="also use"></a>, we can also use
<tt>memcpy()</tt><a name="which copies"></a>, which copies a block
of memory. For example:</p>

<div class="docText">
<pre>
std::memcpy(temp, fibonacci, sizeof(fibonacci));
</pre>
</div>
<br>

<p class="docText"><a name="declare a"></a>When we declare a C++
array, the size must be a constant.<sup class=
"docFootnote"><a class="docLink" href=
"#app04fn02">[*]</a></sup><a name="we want"></a> If we want to
create an array of a variable size, we have several options.</p>

<blockquote>
<p class="docFootnote"><sup><a name=
"app04fn02">[*]</a></sup><a name="should not"></a> Some compilers
allow variables in that context, but this feature should not be
relied upon in portable programs.</p>
</blockquote>

<ul>
<li>
<p class="docList"><span class="docEmphStrong">We can dynamically
allocate the array:</span>
</p>

<div class="docText">
<pre>
int *fibonacci = new int[n];
</pre>
</div>

<p class="docList">The <tt>new []</tt><a name="of items"></a>
operator allocates a certain number of items at consecutive memory
locations and returns a pointer to the first item. Thanks to the
"equivalence of pointers and arrays" principle, the items can be
accessed through the pointer as <tt>fibonacci[0]</tt>,
<tt>fibonacci[1]</tt>, ..., <tt>fibonacci[n - 1]</tt><a name=
"the memory"></a>. When we have finished using the array, we should
release the memory it consumes using the <tt>delete []</tt>
operator:</p>

<div class="docText">
<pre>
delete [] fibonacci;
</pre>
</div>
</li>

<li>
<p class="docList"><span class="docEmphStrong">We can use the
standard vector&lt;T&gt; class:</span>
</p>

<div class="docText">
<pre>
#include &lt;vector&gt;

std::vector&lt;int&gt; fibonacci(n);
</pre>
</div>

<p class="docList"><a name="iddle1529"></a><a name=
"iddle1538"></a><a name="iddle1809"></a><a name=
"iddle3188"></a><a name="iddle6473"></a><a name=
"iddle7420"></a><a name="iddle7793"></a>Items are accessible using
the <tt>[]</tt> operator, just like with a plain C++ array. With
<tt>vector&lt;T&gt;</tt> (where <tt>T</tt><a name="in the"></a> is
the type of the items stored in the vector), we can resize the
array at any time using <tt>resize()</tt><a name=
"contain angle"></a> and we can copy it using the assignment
operator. Classes that contain angle brackets
(<tt>&lt;&gt;</tt><a name="are called"></a>) in their name are
called template classes.</p>
</li>

<li>
<p class="docList"><span class="docEmphStrong"><a name=
"use Qt"></a>We can use Qt's QVector&lt;T&gt; class:</span>
</p>

<div class="docText">
<pre>
#include &lt;QVector&gt;

QVector&lt;int&gt; fibonacci(n);
</pre>
</div>

<p class="docList"><tt>QVector&lt;T&gt;</tt><a name="API is"></a>'s
API is very similar to that of <tt>vector&lt;T&gt;</tt><a name=
"also supports"></a>, but it also supports iteration using Qt's
<tt>foreach</tt><a name="and uses"></a> keyword and uses implicit
data sharing ("copy on write") as a memory and speed optimization.
<a class="docLink" href="ch11.html#ch11">Chapter 11</a><a name=
"the Standard"></a> presents Qt's container classes and explains
how they relate to the Standard C++ containers.</p>
</li>
</ul>

<p class="docText"><a name="avoid built"></a>You might be tempted
to avoid built-in arrays whenever possible and use
<tt>vector&lt;T&gt;</tt> or <tt>QVector&lt;T&gt;</tt><a name=
"because sooner"></a> instead. It is nonetheless worthwhile
understanding how the built-in arrays work because sooner or later
you might want to use them in highly optimized code, or need them
to interface with existing C libraries.</p>
<a name="app04lev2sec6"></a>
<h4 id="title-ID0EZZBO" class="docSection2Title">Character
Strings</h4>

<p class="docText"><a name="strings in"></a>The most basic way to
represent character strings in C++ is to use an array of
<tt>char</tt><a name="demonstrate how"></a>s terminated by a null
byte ('/ 0'). The following four functions demonstrate how these
kinds of strings work:</p>

<div class="docText">
<pre>
void hello1()
{
    const char str[] = {
        'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'
    };
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

void hello2()
{
    const char str[] = "Hello world!";
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

void hello3()
{
    std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;
}

void hello4()
{
    const char *str = "Hello world!";
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1452"></a><a name=
"iddle1528"></a><a name="iddle2425"></a><a name=
"iddle5898"></a><a name="iddle8299"></a><a name="we declare"></a>In
the first function, we declare the string as an array and
initialize it the hard way. Notice the '/0' terminator at the end,
which indicates the end of the string. The second function has a
similar array definition, but this time we use a string literal to
initialize the array. In C++, string literals are simply <tt>const
char</tt><a name="an implicit"></a> arrays with an implicit '/0'
terminator. The third function uses a string literal directly,
without giving it a name. Once translated into machine language
instructions, it is identical to the previous two functions.</p>

<p class="docText"><a name="The fourth"></a>The fourth function is
a bit different in that it creates not only an (anonymous) array,
but also a pointer variable called <tt>str</tt><a name=
"the address"></a> that stores the address of the array's first
item. In spite of this, the semantics of the function are identical
to the previous three functions, and an optimizing compiler would
eliminate the superfluous <tt>str</tt> variable.</p>

<p class="docText"><a name="that take"></a>Functions that take C++
strings as arguments usually take either a <tt>char *</tt> or a
<tt>const char *</tt>. Here's a short program that illustrates the
use of both:</p>

<div class="docText">
<pre>
#include &lt;cctype&gt;
#include &lt;iostream&gt;

void makeUppercase(char *str)
{
    for (int i = 0; str[i] != '\0'; ++i)
        str[i] = std::toupper(str[i]);
}

void writeLine(const char *str)
{
    std::cout &lt;&lt; str &lt;&lt; std::endl;
}

int main(int argc, char *argv[])
{
    for (int i = 1; i &lt; argc; ++i) {
        makeUppercase(argv[i]);
        writeLine(argv[i]);
    }
    return 0;
}
</pre>
</div>
<br>

<p class="docText">In C++, the <tt>char</tt><a name=
"easily store"></a> type normally holds an 8-bit value. This means
that we can easily store ASCII, ISO 8859-1 (Latin-1), and other
8-bit-encoded strings in a <tt>char</tt><a name=
"Unicode characters"></a> array, but that we can't store arbitrary
Unicode characters without resorting to multibyte sequences. Qt
provides the powerful <tt>QString</tt> class, which stores Unicode
strings as sequences of 16-bit <tt>QChar</tt>s and internally uses
the implicit data sharing ("copy on write") optimization. <a class=
"docLink" href="ch11.html#ch11">Chapter 11</a> and <a class=
"docLink" href="ch18.html#ch18">Chapter 18</a> explain
<tt>QString</tt> in more detail.</p>
<a name="app04lev2sec7"></a>
<h4 id="title-ID0EE4BO" class="docSection2Title">Enumerations</h4>

<p class="docText"><a name="named constants"></a>C++ has an
enumeration feature for declaring a set of named constants similar
to that provided by C# and recent versions of Java. Let's suppose
that we want to store days of the week in a program:</p>

<div class="docText">
<pre>
enum DayOfWeek {
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
};
</pre>
</div>
<br>

<p class="docText"><a name="header file"></a>Normally, we would put
this declaration in a header file, or even inside a class. The
preceding declaration is superficially equivalent to the following
constant definitions:</p>

<div class="docText">
<pre>
const int Sunday    = 0;
const int Monday    = 1;
const int Tuesday   = 2;
const int Wednesday = 3;
const int Thursday  = 4;
const int Friday    = 5;
const int Saturday  = 6;
</pre>
</div>
<br>

<p class="docText"><a name="parameters of"></a>By using the
enumeration construct, we can later declare variables or parameters
of type <tt>DayOfWeek</tt><a name="will ensure"></a> and the
compiler will ensure that only values from the
<tt>DayOfWeek</tt><a name="assigned to"></a> enumeration are
assigned to it. For example:</p>

<div class="docText">
<pre>
DayOfWeek day = Sunday;
</pre>
</div>
<br>

<p class="docText"><a name="If we"></a>If we don't care about type
safety, we can also write</p>

<div class="docText">
<pre>
int day = Sunday;
</pre>
</div>
<br>

<p class="docText"><a name="to refer"></a>Notice that to refer to
the <tt>Sunday</tt><a name="from the"></a> constant from the
<tt>DayOfWeek</tt> enum, we simply write <tt>Sunday</tt>, not
<tt>DayOfWeek::Sunday</tt>.</p>

<p class="docText"><a name="constants of"></a>By default, the
compiler assigns consecutive integer values to the constants of an
enum, starting at 0. We can specify other values if we want:</p>

<div class="docText">
<pre>
enum DayOfWeek {
    Sunday    = 628,
    Monday    = 616,
    Tuesday   = 735,
    Wednesday = 932,
    Thursday  = 852,
    Friday    = 607,
    Saturday  = 845
};
</pre>
</div>
<br>

<p class="docText"><a name="of an"></a>If we don't specify the
value of an enum item, the item takes the value of the preceding
item, plus 1. Enums are sometimes used to declare integer
constants, in which case we normally omit the name of the enum:</p>

<div class="docText">
<pre>
enum {
    FirstPort = 1024,
    MaxPorts  = 32767
};
</pre>
</div>
<br>

<p class="docText"><a name="of options"></a>Another frequent use of
enums is to represent sets of options. Let's consider the example
of a Find dialog, with four checkboxes controlling the search
algorithm (<span class="docEmphRomanAlt">Wildcard syntax</span>,
<span class="docEmphRomanAlt">Case sensitive</span>, <span class=
"docEmphRomanAlt">Search backward</span>, and <span class=
"docEmphRomanAlt">Wrap around</span><a name="where the"></a>). We
can represent this by an enum where the constants are powers of
2:</p>

<div class="docText">
<pre>
enum FindOption {
    NoOptions      = 0x00000000,
    WildcardSyntax = 0x00000001,
    CaseSensitive  = 0x00000002,
    SearchBackward = 0x00000004,
    WrapAround     = 0x00000008
};
</pre>
</div>
<br>

<p class="docText"><a name="iddle1032"></a><a name=
"iddle1154"></a><a name="iddle5029"></a><a name=
"iddle8256"></a><a name="using the"></a>Each option is often called
a "flag". We can combine flags using the bitwise <tt>|</tt> or
<tt>|=</tt> operator:</p>

<div class="docText">
<pre>
int options = NoOptions;
if (wilcardSyntaxCheckBox-&gt;isChecked())
    options |= WildcardSyntax;
if (caseSensitiveCheckBox-&gt;isChecked())
    options |= CaseSensitive;
if (searchBackwardCheckBox-&gt;isChecked())
    options |= SearchBackwardSyntax;
if (wrapAroundCheckBox-&gt;isChecked())
    options |= WrapAround;
</pre>
</div>
<br>

<p class="docText"><a name="whether a"></a>We can test whether a
flag is set using the bitwise <tt>&amp;</tt> operator:</p>

<div class="docText">
<pre>
if (options &amp; CaseSensitive) {
    // case-sensitive search
}
</pre>
</div>
<br>

<p class="docText"><a name="of type"></a>A variable of type
<tt>FindOption</tt><a name="can contain"></a> can contain only one
flag at a time. The result of combining several flags using
<tt>|</tt><a name="plain integer"></a> is a plain integer.
Unfortunately, this is not type-safe: The compiler won't complain
if a function expecting a combination of
<tt>FindOption</tt><a name="through an"></a>s through an
<tt>int</tt> parameter receives <tt>Saturday</tt> instead. Qt uses
<tt>QFlags&lt;T&gt;</tt><a name="class is"></a> to provide type
safety for its own flag types. The class is also available when we
define custom flag types. See the <tt>QFlags&lt;T&gt;</tt> online
documentation for details.</p>
<a name="app04lev2sec8"></a>
<h4 id="title-ID0EZCCO" class="docSection2Title">Typedefs</h4>

<p class="docText"><a name="to a"></a>C++ lets us give an alias to
a data type using the <tt>typedef</tt> keyword. For example, if we
use <tt>QVector&lt;Point2D&gt;</tt><a name="are unfortunate"></a> a
lot and want to save a few keystrokes (or are unfortunate enough to
be stuck with a Norwegian keyboard and have trouble locating the
angle brackets), we can put this typedef declaration in one of our
header files:</p>

<div class="docText">
<pre>
typedef QVector&lt;Point2D&gt; PointVector;
</pre>
</div>
<br>

<p class="docText">From then on, we can use <tt>PointVector</tt> as
a shorthand for <tt>QVector&lt;Point2D&gt;</tt><a name=
"type appears"></a>. Notice that the new name for the type appears
after the old name. The typedef syntax deliberately mimics that of
variable declarations.</p>

<p class="docText">In Qt, typedefs are used mainly for three
reasons:</p>

<ul>
<li>
<p class="docText"><span class="docEmphasis">Convenience:</span> Qt
declares <tt>uint</tt> and <tt>QWidgetList</tt> as typedefs for
<tt>unsigned int</tt> and <tt>QList&lt;QWidget *&gt;</tt> to save a
few keystrokes.</p>
</li>

<li>
<p class="docText"><span class="docEmphasis">Platform
differences:</span> <a name="iddle1317"></a><a name=
"iddle1451"></a><a name="iddle1453"></a><a name=
"iddle1460"></a><a name="iddle1490"></a><a name=
"iddle1778"></a><a name="iddle2405"></a><a name=
"iddle3596"></a><a name="iddle4012"></a><a name=
"iddle7724"></a><a name="iddle8430"></a>Certain types need
different definitions on different platforms. For example,
<tt>qlonglong</tt> is defined as <tt>__int64</tt> on Windows and as
<tt>long long</tt> on other platforms.</p>
</li>

<li>
<p class="docText"><span class="docEmphasis">Compatibility:</span>
The <tt>QIconSet</tt> class from Qt 3 was renamed
<tt>QIcon</tt><a name="Qt"></a> in Qt 4. To help Qt 3 users port
their applications to Qt 4, <tt>QIconSet</tt><a name=
"a typedef"></a> is provided as a typedef for
<tt>QIcon</tt><a name="compatibility is"></a> when Qt 3
compatibility is enabled.</p>
</li>
</ul>
<a name="app04lev2sec9"></a>
<h4 id="title-ID0ECICO" class="docSection2Title">Type
Conversions</h4>

<p class="docText"><a name="provides several"></a>C++ provides
several syntaxes for casting values from one type to another. The
traditional syntax, inherited from C, involves putting the
resulting type in parentheses before the value to convert:</p>

<div class="docText">
<pre>
const double Pi = 3.14159265359;
int x = (int)(Pi * 100);
std::cout &lt;&lt; x &lt;&lt; " equals 314" &lt;&lt; std::endl;
</pre>
</div>
<br>

<p class="docText"><a name="is very"></a>This syntax is very
powerful. It can be used to change the types of pointers, to remove
<tt>const</tt><a name="much more"></a>, and much more. For
example:</p>

<div class="docText">
<pre>
short j = 0x1234;
if (*(char *)&amp;j == 0x12)
    std::cout &lt;&lt; "The byte order is big-endian" &lt;&lt; std::endl;
</pre>
</div>
<br>

<p class="docText">In the preceding example, we cast a <tt>short
*</tt> to a <tt>char *</tt> and we use the unary <tt>*</tt><a name=
"On big"></a> operator to access the byte at the given memory
location. On big-endian systems, that byte is <tt>0x12</tt>; on
little-endian systems, it is <tt>0x34</tt><a name=
"represented the"></a>. Since pointers and references are
represented the same way, it should come as no surprise that the
preceding code can be rewritten using a reference cast:</p>

<div class="docText">
<pre>
short j = 0x1234;
if ((char &amp;)j == 0x12)
    std::cout &lt;&lt; "The byte order is big-endian" &lt;&lt; std::endl;
</pre>
</div>
<br>

<p class="docText"><a name="a primitive"></a>If the data type is a
class name, a typedef, or a primitive type that can be expressed as
a single alphanumeric token, we can use the constructor syntax as a
cast:</p>

<div class="docText">
<pre>
int x = int(Pi * 100);
</pre>
</div>
<br>

<p class="docText"><a name="casts is"></a>Casting pointers and
references using the traditional C-style casts is a kind of extreme
sport, on par with paragliding and elevator surfing, because the
compiler lets us cast any pointer (or reference) type into any
other pointer (or reference) type. For that reason, C++ introduced
four new-style casts with more precise semantics. For pointers and
references, the new-style casts are preferable to the risky C-style
casts and are used in this book.</p>

<ul>
<li>
<p class="docList"><tt>static_cast&lt;T&gt;()</tt> can be used to
cast a pointer-to-<tt>A</tt> to a pointer-to-<tt>B</tt>, with the
constraint that class <tt>B</tt> must be a subclass of class
<tt>A</tt>. For example:</p>

<div class="docText">
<pre>
A *obj = new B;
B *b = static_cast&lt;B *&gt;(obj);
b-&gt;someFunctionDeclaredInB();
</pre>
</div>

<p class="docList"><a name="iddle1769"></a><a name=
"iddle1779"></a><a name="iddle2318"></a><a name=
"iddle2324"></a><a name="iddle3960"></a><a name=
"iddle4088"></a><a name="iddle5435"></a><a name=
"iddle5491"></a><a name="iddle6833"></a><a name=
"iddle6978"></a><a name="iddle7000"></a><a name=
"iddle8032"></a><a name="iddle8480"></a>If the object isn't an
instance of <tt>B</tt>, using the resulting pointer can lead to
obscure crashes.</p>
</li>

<li>
<p class="docList"><tt>dynamic_cast&lt;T&gt;()</tt> is similar to
<tt>static_cast&lt;T&gt;()</tt><a name="object associated"></a>,
except that it uses run-time type information (RTTI) to check that
the object associated with the pointer is an instance of class
<tt>B</tt><a name="not the"></a>. If this is not the case, the cast
returns a null pointer. For example:</p>

<div class="docText">
<pre>
A *obj = new B;
B *b = dynamic_cast&lt;B *&gt;(obj);
if (b)
    b-&gt;someFunctionDeclaredInB();
</pre>
</div>

<p class="docList">On some compilers,
<tt>dynamic_cast&lt;T&gt;()</tt><a name="dynamic library"></a>
doesn't work across dynamic library boundaries. It also relies on
the compiler supporting RTTI, a feature that programmers can turn
off to reduce the size of their executables. Qt solves these
problems by providing <tt>qobject_cast&lt;T&gt;()</tt><a name=
"for"></a> for <tt>QObject</tt> subclasses.</p>
</li>

<li>
<p class="docList"><tt>const_cast&lt;T&gt;()</tt><a name=
"removes a"></a> adds or removes a <tt>const</tt><a name=
"to a"></a> qualifier to a pointer or reference. For example:</p>

<div class="docText">
<pre>
int MyClass::someConstFunction() const
{
    if (isDirty()) {
        MyClass *that = const_cast&lt;MyClass *&gt;(this);
        that-&gt;recomputeInternalData();
    }
    ...
}
</pre>
</div>

<p class="docList">In the previous example, we cast away the
<tt>const</tt> qualifier of the <tt>this</tt> pointer to call the
non-const member function <tt>recomputeInternalData()</tt><a name=
"avoided by"></a>. Doing so is not recommended and can normally be
avoided by using the <tt>mutable</tt> keyword, as explained in
<a class="docLink" href="ch04.html#ch04">Chapter 4</a>.</p>
</li>

<li>
<p class="docList"><tt>reinterpret_cast&lt;T&gt;()</tt><a name=
"type to"></a> converts any pointer or reference type to any other
such type. For example:</p>

<div class="docText">
<pre>
short j = 0x1234;
if (reinterpret_cast&lt;char &amp;&gt;(j) == 0x12)
    std::cout &lt;&lt; "The byte order is big-endian" &lt;&lt; std::endl;
</pre>
</div>
</li>
</ul>

<p class="docText"><a name="an"></a>In Java and C#, any reference
can be stored as an <tt>Object</tt><a name="it provides"></a>
reference if needed. C++ doesn't have any universal base class, but
it provides a special data type, <tt>void *</tt>, that stores the
address of an instance of any type. A <tt>void *</tt> must be cast
back to another type (using <tt>static_cast&lt;T&gt;()</tt>) before
it can be used.</p>

<p class="docText"><a name="we don"></a>C++ provides many ways to
cast types, but most of the time we don't even need a cast. When
using container classes such as <tt>vector&lt;T&gt;</tt> or
<tt>QVector&lt;T&gt;</tt><a name="the"></a>, we can specify the
<tt>T</tt><a name="extract items"></a> type and extract items
without casts. In addition, for primitive types, certain
conversions occur implicitly (e.g., from <tt>char</tt><a name=
"to"></a> to <tt>int</tt><a name="custom types"></a>), and for
custom types <a name="iddle1029"></a><a name=
"iddle2681"></a><a name="iddle3756"></a><a name=
"iddle3966"></a><a name="iddle3967"></a><a name=
"iddle4183"></a><a name="iddle4188"></a><a name=
"iddle4203"></a><a name="iddle4370"></a><a name=
"iddle7757"></a><a name="iddle7775"></a><a name=
"iddle7779"></a><a name="can define"></a>we can define implicit
conversions by providing a one-parameter constructor. For
example:</p>

<div class="docText">
<pre>
class MyInteger
{
public:
    MyInteger();
    MyInteger(int i);
    ...
};

int main()
{
    MyInteger n;
    n = 5;
    ...
}
</pre>
</div>
<br>

<p class="docText"><a name="disable it"></a>For some one-parameter
constructors, the automatic conversion makes little sense. We can
disable it by declaring the constructor with the <tt>explicit</tt>
keyword:</p>

<div class="docText">
<pre>
class MyVector
{
public:
    explicit MyVector(int size);
    ...
};
</pre>
</div>
<br>
<a name="app04lev2sec10"></a>
<h4 id="title-ID0EWUCO" class="docSection2Title">Operator
Overloading</h4>

<p class="docText"><a name="that we"></a>C++ allows us to overload
functions, meaning that we can declare several functions with the
same name in the same scope, as long as they have different
parameter lists. In addition, C++ supports <span class=
"docEmphasis">operator overloading</span>—the possibility of
assigning special semantics to built-in operators (such as
<tt>+</tt>, <tt>&lt;&lt;</tt>, and <tt>[]</tt>) when they are used
with custom types.</p>

<p class="docText"><a name="When we"></a>We have already seen a few
examples of overloaded operators. When we used <tt>&lt;&lt;</tt> to
output text to <tt>cout</tt> or <tt>cerr</tt><a name="of the"></a>,
we didn't trigger C++'s left-shift operator, but rather a special
version of the operator that takes an <tt>ostream</tt> object (such
as <tt>cout</tt> and <tt>cerr</tt><a name="a stream"></a>) on the
left side and a string (alternatively, a number or a stream
manipulator such as <tt>endl</tt><a name="side and"></a>) on the
right side and that returns the <tt>ostream</tt><a name=
"calls in"></a> object, allowing multiple calls in a row.</p>

<p class="docText"><a name="The beauty"></a>The beauty of operator
overloading is that we can make custom types behave just like
built-in types. To show how operator overloading works, we will
overload <tt>+=</tt>, <tt>-=</tt>, <tt>+</tt>, and
<tt>-</tt><a name="on"></a> to work on <tt>Point2D</tt>
objects:</p>

<div class="docText">
<div class="codeSegmentsExpansionLinks">Code View:</div>

<pre class="">
#ifndef POINT2D_H
#define POINT2D_H

class Point2D
{
public:
    Point2D();
    Point2D(double x, double y);

    void setX(double x);
    void setY(double y);
    double x() const;
    double y() const;

    Point2D &amp;operator+=(const Point2D &amp;other) {
        xVal += other.xVal;
        yVal += other.yVal;
        return *this;
    }
    Point2D &amp;operator-=(const Point2D &amp;other) {
        xVal -= other.xVal;
        yVal -= other.yVal;
        return *this;
    }

private:
    double xVal;
    double yVal;
};

inline Point2D operator+(const Point2D &amp;a, const Point2D &amp;b)
{
    return Point2D(a.x() + b.x(), a.y() + b.y());
}

inline Point2D operator-(const Point2D &amp;a, const Point2D &amp;b)
{
    return Point2D(a.x() - b.x(), a.y() - b.y());
}

#endif

                                          
</pre>
</div>
<br>

<p class="docText"><a name="iddle8033"></a><a name=
"can be"></a>Operators can be implemented either as member
functions or as global functions. In our example, we implemented
<tt>+=</tt> and <tt>-=</tt> as member functions, and <tt>+</tt> and
<tt>-</tt> as global functions.</p>

<p class="docText">The <tt>+=</tt> and <tt>-=</tt> operators take a
reference to another <tt>Point2D</tt> object and increment or
decrement the <span class="docEmphasis">x</span>- and <span class=
"docEmphasis">y</span><a name="return"></a>-coordinates of the
current object based on the other object. They return
<tt>*this</tt><a name="the current"></a>, which denotes a reference
to the current object (<tt>this</tt> is of type <tt>Point2D
*</tt><a name="such as"></a>). Returning a reference allows us to
write exotic code such as</p>

<div class="docText">
<pre>
a += b += c;
</pre>
</div>
<br>

<p class="docText">The <tt>+</tt> and <tt>-</tt> operators take two
parameters and return a <tt>Point2D</tt><a name=
"existing object"></a> object by value (not a reference to an
existing object). The <tt>inline</tt><a name="header file"></a>
keyword allows us to put these function definitions in the header
file. If the function's body had been longer, we would put a
function prototype in the header file and the function definition
(without the <tt>inline</tt> keyword) in a <tt>.cpp</tt> file.</p>

<p class="docText"><a name="iddle2052"></a><a name=
"iddle3997"></a><a name="iddle6819"></a><a name=
"iddle8402"></a><a name="snippet shows"></a>The following code
snippet shows all four overloaded operators in action:</p>

<div class="docText">
<pre>
Point2D alpha(12.5, 40.0);
Point2D beta(77.5, 50.0);

alpha += beta;
beta -= alpha;

Point2D gamma = alpha + beta;
Point2D delta = beta - alpha;
</pre>
</div>
<br>

<p class="docText"><a name="also invoke"></a>We can also invoke the
<tt>operator</tt><a name="functions just"></a> functions just like
any other functions:</p>

<div class="docText">
<pre>
Point2D alpha(12.5, 40.0);
Point2D beta(77.5, 50.0);

alpha.operator+=(beta);
beta.operator-=(alpha);

Point2D gamma = operator+(alpha, beta);
Point2D delta = operator-(beta, alpha);
</pre>
</div>
<br>

<p class="docText"><a name="in C"></a>Operator overloading in C++
is a complex topic, but we can go a long way without knowing all
the details. It is still important to understand the fundamentals
of operator overloading because several Qt classes (including
<tt>QString</tt> and <tt>QVector&lt;T&gt;</tt><a name=
"this feature"></a>) use this feature to provide a simple and more
natural syntax for such operations as concatenation and append.</p>
<a name="app04lev2sec11"></a>
<h4 id="title-ID0EN1CO" class="docSection2Title">Value Types</h4>

<p class="docText">Java and C# distinguish between value types and
reference types.</p>

<ul>
<li>
<p class="docText"><span class="docEmphasis">Value types:</span>
These are primitive types such as <tt>char</tt>, <tt>int</tt>, and
<tt>float</tt><a name="created using"></a>, as well as C# structs.
What characterizes them is that they aren't created using
<tt>new</tt><a name="a copy"></a> and the assignment operator
performs a copy of the value held by the variable. For example:</p>

<div class="docText">
<pre>
int i = 5;
int j = 10;
i = j;
</pre>
</div>
</li>

<li>
<p class="docText"><span class="docEmphasis">Reference
types:</span> These are classes such as <tt>Integer</tt> (in Java),
<tt>String</tt>, and <tt>MyVeryOwnClass</tt>. Instances are created
using <tt>new</tt><a name="to obtain"></a>. The assignment operator
copies only a reference to the object; to obtain a deep copy, we
must call <tt>clone()</tt> (in Java) or <tt>Clone()</tt> (in C#).
For example:</p>

<div class="docText">
<pre>
Integer i = new Integer(5);
Integer j = new Integer(10);
i = j.clone();
</pre>
</div>
</li>
</ul>

<p class="docText"><a name="and those"></a>In C++, all types can be
used as "reference types", and those that are copyable can be used
as "value types" as well. For example, C++ doesn't need any
<tt>Integer</tt> class, because we can use pointers and
<tt>new</tt> as follows:</p>

<div class="docText">
<pre>
int *i = new int(5);
int *j = new int(10);
*i = *j;
</pre>
</div>
<br>

<p class="docText"><a name="iddle1235"></a><a name=
"iddle1785"></a><a name="iddle1882"></a><a name=
"iddle4174"></a><a name="iddle4368"></a>Unlike Java and C#, C++
treats user-defined classes in the same way as built-in types:</p>

<div class="docText">
<pre>
Point2D *i = new Point2D(5, 5);
Point2D *j = new Point2D(10, 10);
*i = *j;
</pre>
</div>
<br>

<p class="docText"><a name="that our"></a>If we want to make a C++
class copyable, we must ensure that our class has a copy
constructor and an assignment operator. The copy constructor is
invoked when we initialize an object with another object of the
same type. C++ provides two equivalent syntaxes for this:</p>

<div class="docText">
<pre>
Point2D i(20, 20);

Point2D j(i);      // first syntax
Point2D k = i;     // second syntax
</pre>
</div>
<br>

<p class="docText"><a name="is invoked"></a>The assignment operator
is invoked when we use the assignment operator on an existing
variable:</p>

<div class="docText">
<pre>
Point2D i(5, 5);
Point2D j(10, 10);
j = i;
</pre>
</div>
<br>

<p class="docText"><a name="define a"></a>When we define a class,
the C++ compiler automatically provides a copy constructor and an
assignment operator that perform member-by-member copying. For the
<tt>Point2D</tt><a name="this is"></a> class, this is as though we
had written the following code in the class definition:</p>

<div class="docText">
<pre>
class Point2D
{
public:
    ...
    Point2D(const Point2D &amp;other)
        : xVal(other.xVal), yVal(other.yVal) { }

    Point2D &amp;operator=(const Point2D &amp;other) {
        xVal = other.xVal;
        yVal = other.yVal;
        return *this;
    }
    ...

private:
    double xVal;
    double yVal;
};
</pre>
</div>
<br>

<p class="docText"><a name="the default"></a>For some classes, the
default copy constructor and assignment operator are unsuitable.
This typically occurs if the class uses dynamic memory. To make
<a name="iddle1289"></a><a name="iddle2923"></a><a name=
"iddle2926"></a><a name="iddle4020"></a><a name=
"iddle4388"></a><a name="class copyable"></a>the class copyable, we
must then implement the copy constructor and the assignment
operator ourselves.</p>

<p class="docText"><a name="the copy"></a>For classes that don't
need to be copyable, we can disable the copy constructor and
assignment operator by making them private. If we accidentally
attempt to copy instances of such a class, the compiler reports an
error. For example:</p>

<div class="docText">
<pre>
class BankAccount
{
public:
    ...

private:
    BankAccount(const BankAccount &amp;other);
    BankAccount &amp;operator=(const BankAccount &amp;other);
};
</pre>
</div>
<br>

<p class="docText"><a name="to be"></a>In Qt, many classes are
designed to be used as value classes. These have a copy constructor
and an assignment operator, and are normally instantiated on the
stack without <tt>new</tt>. This is the case for
<tt>QDateTime</tt>, <tt>QImage</tt>, <tt>QString</tt>, and
container classes such as <tt>QList&lt;T&gt;</tt>,
<tt>QVector&lt;T&gt;</tt>, and <tt>QMap&lt;K, T&gt;</tt>.</p>

<p class="docText">Other classes fall in the "reference type"
category, notably <tt>QObject</tt> and its subclasses
(<tt>QWidget</tt>, <tt>QTimer</tt>, <tt>QTcpSocket</tt>, etc.).
These have virtual functions and cannot be copied. For example, a
<tt>QWidget</tt> represents a specific window or control on-screen.
If there are 75 <tt>QWidget</tt><a name="classes are"></a>
instances in memory, there are also 75 windows or controls
on-screen. These classes are typically instantiated using the
<tt>new</tt> operator.</p>
<a name="app04lev2sec12"></a>
<h4 id="title-ID0EGCDO" class="docSection2Title">Global Variables
and Functions</h4>

<p class="docText"><a name="belong to"></a>C++ lets us declare
functions and variables that don't belong to any classes and that
are accessible from any other function. We have seen several
examples of global functions, including <tt>main()</tt><a name=
"thread reentrancy"></a>, the program's entry point. Global
variables are rarer, because they compromise modularity and thread
reentrancy. It is still important to understand them because you
might encounter them in code written by reformed C programmers and
other C++ users.</p>

<p class="docText"><a name="global functions"></a>To illustrate how
global functions and variables work, we will study a small program
that prints a list of 128 pseudo-random numbers using a
quick-and-dirty algorithm. The program's source code is spread over
two <tt>.cpp</tt> files.</p>

<p class="docText"><a name="source file"></a>The first source file
is <tt>random.cpp</tt>:</p>

<div class="docText">
<pre>
int randomNumbers[128];

static int seed = 42;

static int nextRandomNumber()
{
    seed = 1009 + (seed * 2011);
    return seed;
}
void populateRandomArray()
{
    for (int i = 0; i &lt; 128; ++i)
        randomNumbers[i] = nextRandomNumber();
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1719"></a><a name=
"iddle2046"></a><a name="iddle2070"></a><a name=
"iddle2692"></a><a name="iddle2694"></a><a name=
"iddle7726"></a><a name="iddle7730"></a><a name="The file"></a>The
file declares two global variables (<tt>randomNumbers</tt> and
<tt>seed</tt><a name="global functions"></a>) and two global
functions (<tt>nextRandomNumber()</tt> and
<tt>populateRandomArray()</tt><a name="of the"></a>). Two of the
declarations contain the <tt>static</tt> keyword; these are visible
only within the current compilation unit (<tt>random.cpp</tt>) and
are said to have <span class="docEmphasis">static
linkage</span><a name="unit in"></a>. The two others can be
accessed from any compilation unit in the program; these have
<span class="docEmphasis">external linkage</span>.</p>

<p class="docText"><a name="helper functions"></a>Static linkage is
ideal for helper functions and internal variables that should not
be used in other compilation units. It reduces the risks of having
colliding identifiers (global variables with the same name or
global functions with the same signature in different compilation
units) and prevents malicious or otherwise ill-advised users from
accessing the internals of a compilation unit.</p>

<p class="docText">Let's now look at the second file,
<tt>main.cpp</tt><a name="linkage in"></a>, which uses the two
global variables declared with external linkage in
<tt>random.cpp</tt>:</p>

<div class="docText">
<pre>
#include &lt;iostream&gt;

extern int randomNumbers[128];

void populateRandomArray();

int main()
{
    populateRandomArray();
    for (int i = 0; i &lt; 128; ++i)
        std::cout &lt;&lt; randomNumbers[i] &lt;&lt; std::endl;
    return 0;
}
</pre>
</div>
<br>

<p class="docText"><a name="before we"></a>We declare the external
variables and functions before we call them. The external variable
declaration (which makes an external variable visible in the
current compilation unit) for <tt>randomNumbers</tt> starts with
the <tt>extern</tt> keyword. Without <tt>extern</tt><a name=
"variable"></a>, the compiler would think it has to deal with a
variable <span class="docEmphasis">definition</span><a name=
"would complain"></a>, and the linker would complain because the
same variable is defined in two compilation units
(<tt>random.cpp</tt> and <tt>main.cpp</tt><a name=
"be declared"></a>). Variables can be declared as many times as we
want, but they may be defined only once. The definition is what
causes the compiler to reserve space for the variable.</p>

<p class="docText"><a name="The"></a>The
<tt>populateRandomArray()</tt><a name="declared using"></a>
function is declared using a function prototype. The
<tt>extern</tt><a name="is optional"></a> keyword is optional for
functions.</p>

<p class="docText"><a name="in a"></a>Typically, we would put the
external variable and function declarations in a header file and
include it in all the files that need them:</p>

<div class="docText">
<pre>
#ifndef RANDOM_H
#define RANDOM_H
extern int randomNumbers[128];

void populateRandomArray();

#endif
</pre>
</div>
<br>

<p class="docText"><a name="iddle3612"></a><a name=
"iddle3980"></a><a name="iddle4019"></a><a name="iddle7727"></a>We
have already seen how <tt>static</tt><a name=
"member variables"></a> can be used to declare member variables and
functions that are not attached to a specific instance of the
class, and now we have seen how to use it to declare functions and
variables with static linkage. There is one more use of the
<tt>static</tt><a name="declare a"></a> keyword that should be
noted in passing. In C++, we can declare a local variable static.
Such variables are initialized the first time the function is
called and hold their value between function invocations. For
example:</p>

<div class="docText">
<pre>
void nextPrime()
{
    static int n = 1;

    do {
        ++n;
    } while (!isPrime(n));

    return n;
}
</pre>
</div>
<br>

<p class="docText"><a name="except that"></a>Static local variables
are similar to global variables, except that they are only visible
inside the function where they are defined.</p>
<a name="app04lev2sec13"></a>
<h4 id="title-ID0EJIDO" class="docSection2Title">Namespaces</h4>

<p class="docText"><a name="clashes in"></a>Namespaces are a
mechanism for reducing the risks of name clashes in C++ programs.
Name clashes are often an issue in large programs that use several
third-party libraries. In your own programs, you can choose whether
you want to use namespaces.</p>

<p class="docText"><a name="namespace around"></a>Typically, we put
a namespace around all the declarations in a header file to ensure
that the identifiers declared in that header file don't leak into
the global namespace. For example:</p>

<div class="docText">
<pre>
#ifndef SOFTWAREINC_RANDOM_H
#define SOFTWAREINC_RANDOM_H

namespace SoftwareInc
{
    extern int randomNumbers[128];

    void populateRandomArray();
}

#endif
</pre>
</div>
<br>

<p class="docText"><a name="have also"></a>(Notice that we have
also renamed the preprocessor macro used to avoid multiple
inclusions, reducing the risk of a name clash with a header file of
the same name but located in a different directory.)</p>

<p class="docText"><a name="iddle1020"></a><a name=
"iddle4021"></a><a name="iddle4389"></a><a name=
"iddle6020"></a><a name="iddle7742"></a><a name=
"The namespace"></a>The namespace syntax is similar to that of a
class, but it doesn't end with a semicolon. Here's the new
<tt>random.cpp</tt> file:</p>

<div class="docText">
<pre>
#include "random.h"

int SoftwareInc::randomNumbers[128];

static int seed = 42;

static int nextRandomNumber()
{
    seed = 1009 + (seed * 2011);
    return seed;
}

void SoftwareInc::populateRandomArray()
{
    for (int i = 0; i &lt; 128; ++i)
        randomNumbers[i] = nextRandomNumber();
}
</pre>
</div>
<br>

<p class="docText"><a name="can be"></a>Unlike classes, namespaces
can be "reopened" at any time. For example:</p>

<div class="docText">
<pre>
namespace Alpha
{
    void alpha1();
    void alpha2();
}

namespace Beta
{
    void beta1();
}

namespace Alpha
{
    void alpha3();
}
</pre>
</div>
<br>

<p class="docText"><a name="makes it"></a>This makes it possible to
define hundreds of classes, located in as many header files, as
part of a single namespace. Using this trick, the Standard C++
library puts all its identifiers in the <tt>std</tt> namespace. In
Qt, namespaces are used for global-like identifiers such as
<tt>Qt::AlignBottom</tt> and <tt>Qt::yellow</tt><a name=
"namespace but"></a>. For historical reasons, Qt classes do not
belong to any namespace but are prefixed with the letter 'Q'.</p>

<p class="docText"><a name="declared in"></a>To refer to an
identifier declared in a namespace from outside the namespace, we
prefix it with the name of the namespace (and <tt>::</tt><a name=
"are aimed"></a>). Alternatively, we can use one of the following
three mechanisms, which are aimed at reducing the number of
keystrokes we must type.</p>

<ul>
<li>
<p class="docList"><span class="docEmphStrong">We can define a
namespace alias:</span>
</p>

<div class="docText">
<pre>
namespace ElPuebloDeLaReinaDeLosAngeles
{
    void beverlyHills();
    void culverCity();
    void malibu();
    void santaMonica();
}

namespace LA = ElPuebloDeLaReinaDeLosAngeles;
</pre>
</div>

<p class="docList"><a name="iddle3198"></a><a name=
"iddle4419"></a><a name="iddle8368"></a><a name=
"iddle8369"></a><a name="used instead"></a>After the alias
definition, the alias can be used instead of the original name.</p>
</li>

<li>
<p class="docList"><span class="docEmphStrong">We can import a
single identifier from a namespace:</span>
</p>

<div class="docText">
<pre>
int main()
{
    using ElPuebloDeLaReinaDeLosAngeles::beverlyHills;

    beverlyHills();
    ...
}
</pre>
</div>

<p class="docList">The <tt>using</tt><a name=
"namespace without"></a> declaration allows us to access a given
identifier from a namespace without having to prefix it with the
name of the namespace.</p>
</li>

<li>
<p class="docList"><span class="docEmphStrong"><a name=
"an entire"></a>We can import an entire namespace with a single
directive:</span>
</p>

<div class="docText">
<pre>
int main()
{
    using namespace ElPuebloDeLaReinaDeLosAngeles;

    santaMonica();
    malibu();
    ...
}
</pre>
</div>

<p class="docList"><a name="name clashes"></a>With this approach,
name clashes are more likely to occur. If the compiler complains
about an ambiguous name (e.g., two classes with the same name
defined in two different namespaces), we can always qualify the
identifier with the name of the namespace when referring to it.</p>
</li>
</ul>
<a name="app04lev2sec14"></a>
<h4 id="title-ID0ECODO" class="docSection2Title">The
Preprocessor</h4>

<p class="docText"><a name="The C"></a>The C++ preprocessor is a
program that converts a <tt>.cpp</tt><a name="containing"></a>
source file containing <tt>#</tt><a name="as"></a> directives (such
as <tt>#include</tt>, <tt>#ifndef</tt>, and <tt>#endif</tt><a name=
"directives perform"></a>) into a source file that contains no such
directives. These directives perform simple textual operations on
the source file, such as conditional compilation, file inclusion,
and macro expansion. Normally, the preprocessor is invoked
automatically by the compiler, but most systems still offer a way
to invoke it alone (often through a <tt>-E</tt> or <tt>/E</tt>
compiler option).</p>

<ul>
<li>
<p class="docList">The <tt>#include</tt><a name="of the"></a>
directive expands to the contents of the file specified within
angle brackets (<tt>&lt;&gt;</tt>) or double quotes
(<tt>""</tt><a name="a standard"></a>), depending on whether the
header file is installed at a standard location or is part of the
current project. The file name may contain <tt>..</tt> and
<tt>/</tt><a name="For example"></a> (which Windows compilers
correctly interpret as a directory separator). For example:</p>

<div class="docText">
<pre>
#include "../shared/globaldefs.h"
</pre>
</div>
</li>

<li>
<p class="docList"><a name="iddle1730"></a><a name=
"iddle2066"></a><a name="iddle2067"></a><a name=
"iddle2363"></a><a name="iddle2366"></a><a name=
"iddle2408"></a><a name="iddle3142"></a><a name=
"iddle3649"></a><a name="iddle8286"></a>The <tt>#define</tt>
directive defines a macro. Occurrences of the macro appearing after
the <tt>#define</tt> directive are replaced with the macro's
definition. For example, the directive</p>

<div class="docText">
<pre>
#define PI 3.14159265359
</pre>
</div>

<p class="docList"><a name="token"></a>tells the preprocessor to
replace all future occurrences of the token <tt>PI</tt><a name=
"compilation unit"></a> in the current compilation unit with the
token <tt>3.14159265359</tt><a name="clashes with"></a>. To avoid
clashes with variable and class names, it is common practice to
give macros all-uppercase names. It is possible to define macros
that take arguments:</p>

<div class="docText">
<pre>
#define SQUARE(x) ((x) * (x))
</pre>
</div>

<p class="docList"><a name="In the"></a>In the macro body, it is
good style to surround all occurrences of the parameters with
parentheses, as well as the entire body, to avoid problems with
operator precedence. After all, we want <tt>7 * SQUARE(2 +
3)</tt><a name="to"></a> to expand to <tt>7 * ((2 + 3) * (2 +
3))</tt><a name="to"></a>, not to <tt>7 * 2 + 3 * 2 + 3</tt>.</p>

<p class="docList"><a name="command line"></a>C++ compilers
normally allow us to define macros on the command line, using the
<tt>-D</tt> or <tt>/D</tt> option. For example:</p>

<div class="docText">
<pre>
CC -DPI=3.14159265359 -c main.cpp
</pre>
</div>

<p class="docList"><a name="the old"></a>Macros were very popular
in the old days, before typedefs, enums, constants, inline
functions, and templates were introduced. Nowadays, their most
important role is to protect header files against multiple
inclusions.</p>
</li>

<li>
<p class="docList">Macros can be undefined at any point using
<tt>#undef</tt>:</p>

<div class="docText">
<pre>
#undef PI
</pre>
</div>

<p class="docList"><a name="since the"></a>This is useful if we
want to redefine a macro, since the preprocessor doesn't let us
define the same macro twice. It is also useful to control
conditional compilation.</p>
</li>

<li>
<p class="docList"><a name="skipped using"></a>Portions of code can
be processed or skipped using <tt>#if</tt>, <tt>#elif</tt>,
<tt>#else</tt>, and <tt>#endif</tt>, based on the numeric value of
macros. For example:</p>

<div class="docText">
<pre>
#define NO_OPTIM         0
#define OPTIM_FOR_SPEED  1
#define OPTIM_FOR_MEMORY 2

#define OPTIMIZATION     OPTIM_FOR_MEMORY

...

#if OPTIMIZATION == OPTIM_FOR_SPEED
typedef int MyInt;
#elif OPTIMIZATION == OPTIM_FOR_MEMORY
typedef short MyInt;
#else
typedef long long MyInt;
#endif
</pre>
</div>

<p class="docList"><a name="iddle2458"></a><a name=
"iddle3143"></a><a name="iddle3146"></a>In the preceding example,
only the second <tt>typedef</tt> declaration would be processed by
the compiler, resulting in <tt>MyInt</tt> being defined as a
synonym for <tt>short</tt>. By changing the definition of the
<tt>OPTIMIZATION</tt><a name="to be"></a> macro, we get different
programs. If a macro isn't defined, its value is taken to be 0.</p>

<p class="docList"><a name="conditional compilation"></a>Another
approach to conditional compilation is to test whether a macro is
defined. This can be done using the using the <tt>defined()</tt>
operator as follows:</p>

<div class="docText">
<pre>
#define OPTIM_FOR_MEMORY

...

#if defined(OPTIM_FOR_SPEED)
typedef int MyInt;
#elif defined(OPTIM_FOR_MEMORY)
typedef short MyInt;
#else
typedef long long MyInt;
#endif
</pre>
</div>
</li>

<li>
<p class="docList"><a name="preprocessor recognizes"></a>For
convenience, the preprocessor recognizes <tt>#ifdef X</tt><a name=
"and"></a> and <tt>#ifndef X</tt><a name="for"></a> as synonyms for
<tt>#if defined(X)</tt> and <tt>#if !defined(X)</tt><a name=
"protect a"></a>. To protect a header file against multiple
inclusions, we wrap its contents with the following idiom:</p>

<div class="docText">
<pre>
#ifndef MYHEADERFILE_H
#define MYHEADERFILE_H

...

#endif
</pre>
</div>

<p class="docList">The first time the header file is included, the
symbol <tt>MYHEADERFILE_H</tt> is not defined, so the compiler
processes the code between <tt>#ifndef</tt> and
<tt>#endif</tt><a name="is included"></a>. The second and any
subsequent times the header file is included,
<tt>MYHEADERFILE_H</tt> is defined, so the entire <tt>#ifndef ...
#endif</tt> block is skipped.</p>
</li>

<li>
<p class="docList">The <tt>#error</tt><a name="at compile"></a>
directive emits a user-defined error message at compile time. This
is often used in conjunction with conditional compilation to report
an impossible case. For example:</p>

<div class="docText">
<pre>
class UniChar
{
public:
#if BYTE_ORDER == BIG_ENDIAN
    uchar row;
    uchar cell;
#elif BYTE_ORDER == LITTLE_ENDIAN
    uchar cell;
    uchar row;
#else
#error "BYTE_ORDER must be BIG_ENDIAN or LITTLE_ENDIAN"
#endif
};
</pre>
</div>
</li>
</ul>

<p class="docText"><a name="iddle1042"></a><a name=
"iddle1287"></a><a name="iddle1458"></a><a name=
"iddle2646"></a><a name="iddle3281"></a><a name=
"iddle3305"></a><a name="iddle4097"></a><a name=
"iddle4784"></a><a name="iddle5304"></a><a name=
"iddle5374"></a><a name="iddle5899"></a><a name=
"iddle7696"></a><a name="alone on"></a>Unlike most other C++
constructs, where whitespace is irrelevant, preprocessor directives
stand alone on a line and require no semicolon. Very long
directives can be split across multiple lines by ending every line
except the last with a backslash.</p>
</div>
</div>

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td align="right">
<div style="MARGIN-LEFT: 0.15in;"><a href=
"app04lev1sec1.html"><img src="images/prev.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Previous Page"></a> <a href=
"app04lev1sec3.html"><img src="images/next.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Next Page"></a></div>
</td>
</tr>
</table>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("sources/" + chmtop.c2wtopf.pageid);
}
</script>

<!-- CHM2WEB -->
<!-- DO NOT DELETE OR MODIFY THIS CODE WITHOUT 
     WRITTEN PERMISSION OF A!K RESEARCH LABS -->
<table width="100%" cellspacing="0" cellpadding="0" 
style="margin-top: 0pt; border-collapse: collapse;"> 
<tr> <td align="right" style="background-color:white; border-top: 1px solid gray;"> 
<a href="http://chm2web.aklabs.com" target="_blank" style="font-family: sans-serif;  font-size: 11px; text-decoration: none;"><font color="gray">Converted from CHM to HTML with <b>chm2web Pro 2.85 (unicode)</b></font></a>
</td></tr></table> 
<!-- /CHM2WEB -->

</body>
</html>
