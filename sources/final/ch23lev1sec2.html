<html>
<head><meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="generator" content="chm2web Pro 2.85 (unicode)" />

<title>ch23lev1sec2.html</title>
<link rel="stylesheet" href="../../files/helpindex.css" type=
"text/css">
<link rel="stylesheet" href="../../default.css" type="text/css">

<script type="text/JavaScript" src="../../files/supply.js"></script>
<script type="text/JavaScript">
chmtop.c2wtopf.pageid = "final/ch23lev1sec2.html";
</script>

</head>
<body><script type="text/JavaScript"> 
if (window.name != "content") 
  document.write(" <table width=\"100%\" bgcolor=\"#e1e1e1\"cellspacing=\"2\" cellpadding=\"0\" style=\"border-collapse: collapse; font-family: sans-serif; font-size: 14px; color: #000000; text-decoration: none;  \"> <tr> <td align=\"center\" style=\"border-bottom: 2px solid gray\" > <br>&nbsp;Click <a href=\"../../index.html?page=sources%2Ffinal%2Fch23lev1sec2.html\">here</a> to show toolbars of the Web Online Help System: <a href=\"../../index.html?page=sources%2Ffinal%2Fch23lev1sec2.html\">show toolbars</a><br>&nbsp;</td></tr></table><br> "); 
</script>
<!-- !chm2web! -->

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td align="right">
<div style="MARGIN-LEFT: 0.15in;"><a href=
"ch23lev1sec1.html"><img src="images/prev.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Previous Page"></a> <a href=
"ch23lev1sec3.html"><img src="images/next.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Next Page"></a></div>
</td>
</tr>
</table>

<div style="">
<div><a name="ch23lev1sec2"></a>
<h3 class="docSection1Title" id="-100000">Using ActiveX on
Windows</h3>

<p class="docText"><a name="ActiveX technology"></a>Microsoft's
ActiveX technology allows applications to incorporate user
interface components provided by other applications or libraries.
It is built on Microsoft COM and defines one set of interfaces for
applications that use components and another set of interfaces for
applications and libraries that provide components.</p>

<p class="docText"><a name="Edition provides"></a>The Qt/Windows
Desktop Edition provides the ActiveQt framework to seamlessly
combine ActiveX and Qt. ActiveQt consists of two modules:</p>

<ul>
<li>
<p class="docList">The <span class=
"docEmphasis">QAxContainer</span><a name="allows us"></a> module
allows us to use COM objects and to embed ActiveX controls in Qt
applications.</p>
</li>

<li>
<p class="docList">The <span class=
"docEmphasis">QAxServer</span><a name="ActiveX controls"></a>
module allows us to export custom COM objects and ActiveX controls
written using Qt.</p>
</li>
</ul>

<p class="docText"><a name="the Windows"></a>Our first example will
embed the Windows Media Player in a Qt application using the
<span class="docEmphasis">QAxContainer</span> module (see <a class=
"docLink" href="#ch23fig03">Figure 23.3</a>). The Qt application
adds an <span class="docEmphRomanAlt">Open</span> button, a
<span class="docEmphRomanAlt">Play/Pause</span> button, a
<span class="docEmphRomanAlt">Stop</span> button, and a slider to
the Windows Media Player ActiveX control.</p>
<a name="ch23fig03"></a>
<center>
<h5 class="docFigureTitle">Figure 23.3. The Media Player
application</h5>

<p class="docText"><img border="0" id="" width="267" height="300"
src=
"images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cHBhZWhqZHIveWVtc2NpaWEuZ3Bs.jpg"
alt="">
</p>
</center>
<br>

<p class="docText">The application's main window is of type
<tt>PlayerWindow</tt>:</p>

<div class="docText">
<div class="codeSegmentsExpansionLinks">Code View:</div>

<pre class="">
class PlayerWindow : public QWidget
{
    Q_OBJECT
    Q_ENUMS(ReadyStateConstants)

public:
    enum PlayStateConstants { Stopped = 0, Paused = 1, Playing = 2 };
    enum ReadyStateConstants { Uninitialized = 0, Loading = 1,
                               Interactive = 3, Complete = 4 };
    PlayerWindow();

protected:
    void timerEvent(QTimerEvent *event);
private slots:
    void onPlayStateChange(int oldState, int newState);
    void onReadyStateChange(ReadyStateConstants readyState);
    void onPositionChange(double oldPos, double newPos);
    void sliderValueChanged(int newValue);
    void openFile();

private:
    QAxWidget *wmp;
    QToolButton *openButton;
    QToolButton *playPauseButton;
    QToolButton *stopButton;
    QSlider *seekSlider;
    QString fileFilters;
    int updateTimer;
};

                                          
</pre>
</div>
<br>

<p class="docText"><a name="iddle4324"></a><a name=
"iddle4593"></a><a name="iddle4751"></a><a name=
"iddle4771"></a><a name="iddle4777"></a><a name=
"iddle4778"></a><a name="iddle7162"></a><a name=
"iddle7470"></a><a name="iddle7541"></a>The <tt>PlayerWindow</tt>
class is derived from <tt>QWidget</tt>. The <tt>Q_ENUMS()</tt>
macro (just below <tt>Q_OBJECT</tt>) is necessary to tell
<tt>moc</tt> that the <tt>ReadyStateConstants</tt> type used in the
<tt>onReadyStateChange()</tt><a name="a"></a> slot is an enum type.
In the private section, we declare a <tt>QAxWidget *</tt> member
variable.</p>

<div class="docText">
<pre>
PlayerWindow::PlayerWindow()
{
    wmp = new QAxWidget;
    wmp-&gt;setControl("{22D6F312-B0F6-11D0-94AB-0080C74C7E95}");
</pre>
</div>
<br>

<p class="docText">In the constructor, we start by creating a
<tt>QAxWidget</tt><a name="ActiveX control"></a> object to
encapsulate the Windows Media Player ActiveX control. The
<span class="docEmphasis">QAxContainer</span> module consists of
three classes: <tt>QAxObject</tt> encapsulates a COM object,
<tt>QAxWidget</tt> encapsulates an ActiveX control, and
<tt>QAxBase</tt> implements the core COM functionality for
<tt>QAxObject</tt> and <tt>QAxWidget</tt>. The relationships
between these classes are illustrated in <a class="docLink" href=
"#ch23fig04">Figure 23.4</a>.</p>

<p class="docText">
</p>
<a name="ch23fig04"></a>
<center>
<h5 class="docFigureTitle">Figure 23.4. Inheritance tree for the
<span class="docEmphasis">QAxContainer</span> module</h5>

<p class="docText"><img border="0" id="" width="226" height="94"
src=
"images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC4zaGZpZmcvaXMyaWNnMDQ-.jpg"
alt="">
</p>
</center>
<br>

<p class="docText"><a name="iddle1834"></a><a name=
"iddle2312"></a><a name="iddle2890"></a><a name=
"iddle3128"></a><a name="iddle4108"></a><a name=
"iddle4537"></a><a name="iddle4753"></a><a name=
"iddle5472"></a><a name="iddle6456"></a><a name=
"iddle6602"></a><a name="iddle7292"></a><a name=
"iddle7323"></a><a name="iddle8414"></a><a name="iddle8582"></a>We
call <tt>setControl()</tt> on the <tt>QAxWidget</tt><a name=
"will create"></a> with the class ID of the Windows Media Player
6.4 control. This will create an instance of the required
component. From then on, all the properties, events, and methods of
the ActiveX control are available as Qt properties, signals, and
slots through the <tt>QAxWidget</tt> object.</p>

<p class="docText"><a name="types are"></a>The COM data types are
automatically converted into the corresponding Qt types, as
summarized in <a class="docLink" href="#ch23fig05">Figure
23.5</a><a name="of type"></a>. For example, an in-parameter of
type <tt>VARIANT_BOOL</tt><a name="becomes a"></a> becomes a
<tt>bool</tt><a name="of type"></a>, and an out-parameter of type
<tt>VARIANT_BOOL</tt><a name="a"></a> becomes a <tt>bool
&amp;</tt>. If the resulting type is a Qt class (<tt>QString</tt>,
<tt>QDateTime</tt>, etc.), the in-parameter is a const reference
(e.g., <tt>const QString &amp;</tt>).</p>
<a name="ch23fig05"></a>
<h5 class="docTableTitle">Figure 23.5. Relationship between COM
types and Qt types</h5>

<table cellspacing="0" class="allBorders" border="1">
<colgroup align="left" span="2">
<col width="350">
<col width="200">
</colgroup>

<thead>
<tr>
<th scope="col" class="docTableCell thead" align="center" valign=
"top" style="background-color:#E6E6E6">COM Types</th>
<th scope="col" class="docTableCell thead" align="center" valign=
"top" style="background-color:#E6E6E6">Qt Types</th>
</tr>
</thead>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>VARIANT_BOOL</tt>
</td>
<td class="docTableCell" align="left" valign="top"><tt>bool</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>char</tt><span class="docEmphRomanAlt">,</span>
<tt>short</tt><span class="docEmphRomanAlt">,</span>
<tt>int</tt><span class="docEmphRomanAlt">,</span>
<tt>long</tt></td>
<td class="docTableCell" align="left" valign="top"><tt>int</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>unsigned
char</tt><span class="docEmphRomanAlt">,</span> <tt>unsigned
short</tt><span class="docEmphRomanAlt">,</span> <tt>unsigned
int</tt><span class="docEmphRomanAlt">,</span> <tt>unsigned
long</tt></td>
<td class="docTableCell" align="left" valign="top"><tt>uint</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>float</tt><span class="docEmphRomanAlt">,</span>
<tt>double</tt></td>
<td class="docTableCell" align="left" valign="top"><tt>double</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>CY</tt>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>qlonglong</tt><span class="docEmphRomanAlt">,</span>
<tt>qulonglong</tt></td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>BSTR</tt>
</td>
<td class="docTableCell" align="left" valign="top"><tt>QString</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>DATE</tt>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>QDateTime</tt><span class="docEmphRomanAlt">,</span>
<tt>QDate</tt><span class="docEmphRomanAlt">,</span>
<tt>QTime</tt></td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>OLE_COLOR</tt>
</td>
<td class="docTableCell" align="left" valign="top"><tt>QColor</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>SAFEARRAY(VARIANT)</tt>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>QList&lt;QVariant&gt;</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>SAFEARRAY(BSTR)</tt>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>QStringList</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top">
<tt>SAFEARRAY(BYTE)</tt>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>QByteArray</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>VARIANT</tt>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>QVariant</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>IFontDisp
*</tt>
</td>
<td class="docTableCell" align="left" valign="top"><tt>QFont</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><tt>IPictureDisp
*</tt>
</td>
<td class="docTableCell" align="left" valign="top"><tt>QPixmap</tt>
</td>
</tr>

<tr>
<td class="docTableCell" align="left" valign="top"><span class=
"docEmphRomanAlt">User defined type</span>
</td>
<td class="docTableCell" align="left" valign="top">
<tt>QRect</tt><span class="docEmphRomanAlt">,</span>
<tt>QSize</tt><span class="docEmphRomanAlt">,</span>
<tt>QPoint</tt></td>
</tr>
</table>
<br>

<p class="docText"><a name="in a"></a>To obtain the list of the
properties, signals, and slots available in a <tt>QAxObject</tt> or
<tt>QAxWidget</tt> with their Qt data types, call
<tt>QAxBase::generateDocumentation()</tt> or use Qt's
<tt>dumpdoc</tt> command-line tool, located in Qt's
<tt>tools\activeqt\dumpdoc</tt> directory.</p>

<p class="docText">Let's continue with the <tt>PlayerWindow</tt>
constructor:</p>

<div class="docText">
<pre>
    wmp-&gt;setProperty("ShowControls", false);
    wmp-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    connect(wmp, SIGNAL(PlayStateChange(int, int)),
            this, SLOT(onPlayStateChange(int, int)));
    connect(wmp, SIGNAL(ReadyStateChange(ReadyStateConstants)),
            this, SLOT(onReadyStateChange(ReadyStateConstants)));
    connect(wmp, SIGNAL(PositionChange(double, double)),
            this, SLOT(onPositionChange(double, double)));
</pre>
</div>
<br>

<p class="docText">After calling <tt>QAxWidget::setControl()</tt>,
we call <tt>QObject::setProperty()</tt> to set the
<tt>ShowControls</tt><a name="Player to"></a> property of the
Windows Media Player to <tt>false</tt>, since we provide our own
buttons to manipulate the component.
<tt>QObject::setProperty()</tt><a name="normal Qt"></a> can be used
both for COM properties and for normal Qt properties. Its second
parameter is of type <tt>QVariant</tt>.</p>

<p class="docText">Next, we call <tt>setSizePolicy()</tt><a name=
"the available"></a> to make the ActiveX control take all the
available space in the layout, and we connect three ActiveX events
from the COM component to three slots.</p>

<div class="docText">
<pre>
    ...
    stopButton = new QToolButton;
    stopButton-&gt;setText(tr("&amp;Stop"));
    stopButton-&gt;setEnabled(false);
    connect(stopButton, SIGNAL(clicked()), wmp, SLOT(Stop()));
    ...
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1400"></a><a name=
"iddle1996"></a><a name="iddle2036"></a><a name=
"iddle2559"></a><a name="iddle3147"></a><a name=
"iddle3316"></a><a name="iddle4109"></a><a name=
"iddle4129"></a><a name="iddle4325"></a><a name=
"iddle4547"></a><a name="iddle5465"></a><a name=
"iddle5476"></a><a name="iddle7002"></a><a name=
"iddle8083"></a><a name="iddle8086"></a><a name=
"iddle8407"></a><a name="iddle8408"></a><a name="iddle8583"></a>The
rest of the <tt>PlayerWindow</tt><a name="signals to"></a>
constructor follows the usual pattern, except that we connect some
Qt signals to slots provided by the COM object (<tt>Play()</tt>,
<tt>Pause()</tt>, and <tt>Stop()</tt><a name="are similar"></a>).
Since the buttons are similar, we have shown only the <span class=
"docEmphRomanAlt">Stop</span> button's implementation here.</p>

<p class="docText"><a name="constructor and"></a>Let's leave the
constructor and look at the <tt>timerEvent()</tt> function:</p>

<div class="docText">
<pre>
void PlayerWindow::timerEvent(QTimerEvent *event)
{
    if (event-&gt;timerId() == updateTimer) {
        double curPos = wmp-&gt;property("CurrentPosition").toDouble();
        onPositionChange(-1, curPos);
    } else {
        QWidget::timerEvent(event);
    }
}
</pre>
</div>
<br>

<p class="docText"><a name="The"></a>The
<tt>timerEvent()</tt><a name="called at"></a> function is called at
regular intervals while a media clip is playing. We use it to
advance the slider. This is done by calling
<tt>property()</tt><a name="the ActiveX"></a> on the ActiveX
control to obtain the value of the <tt>CurrentPosition</tt>
property as a <tt>QVariant</tt> and calling <tt>toDouble()</tt> to
convert it to a <tt>double</tt>. We then call
<tt>onPositionChange()</tt> to perform the update.</p>

<p class="docText"><a name="iddle1266"></a><a name=
"iddle1366"></a><a name="iddle1734"></a><a name=
"iddle1974"></a><a name="iddle2316"></a><a name=
"iddle2568"></a><a name="iddle3138"></a><a name=
"iddle3258"></a><a name="iddle3266"></a><a name=
"iddle3373"></a><a name="iddle3814"></a><a name=
"iddle4467"></a><a name="iddle4752"></a><a name=
"iddle4754"></a><a name="iddle4755"></a><a name=
"iddle4756"></a><a name="iddle4772"></a><a name=
"iddle4774"></a><a name="iddle4779"></a><a name=
"iddle6425"></a><a name="iddle6426"></a><a name=
"iddle6843"></a><a name="iddle7464"></a><a name=
"iddle7536"></a><a name="iddle7828"></a><a name=
"iddle7829"></a><a name="iddle7830"></a><a name=
"because most"></a>We will not review the rest of the code because
most of it isn't directly relevant to ActiveX and doesn't show
anything that we haven't covered already. The code is included with
the book's examples.</p>

<p class="docText">In the <tt>.pro</tt><a name="link with"></a>
file, we need this entry to link with the <span class=
"docEmphasis">QAxContainer</span> module:</p>

<div class="docText">
<pre>
CONFIG += qaxcontainer
</pre>
</div>
<br>

<p class="docText"><a name="to be"></a>One frequent need when
dealing with COM objects is to be able to call a COM method
directly (as opposed to connecting it to a Qt signal). The easiest
way to do this is to invoke <tt>QAxBase::dynamicCall()</tt><a name=
"method as"></a> with the name and signature of the method as the
first parameter and the arguments to the method as additional
parameters. For example:</p>

<div class="docText">
<pre>
wmp-&gt;dynamicCall("TitlePlay(uint)", 6);
</pre>
</div>
<br>

<p class="docText">The <tt>dynamicCall()</tt> function takes up to
eight parameters of type <tt>QVariant</tt> and returns a
<tt>QVariant</tt>. If we need to pass an <tt>IDispatch *</tt> or an
<tt>IUnknown *</tt> this way, we can encapsulate the component in a
<tt>QAxObject</tt> and call <tt>asVariant()</tt> on it to convert
it to a <tt>QVariant</tt><a name="an"></a>. If we need to call a
COM method that returns an <tt>IDispatch *</tt> or an <tt>IUnknown
*</tt><a name="need to"></a>, or if we need to access a COM
property of one of those types, we can use
<tt>querySubObject()</tt> instead:</p>

<div class="docText">
<pre>
QAxObject *session = outlook.querySubObject("Session");
QAxObject *defaultContacts =
        session-&gt;querySubObject("GetDefaultFolder(OlDefaultFolders)",
                                "olFolderContacts");
</pre>
</div>
<br>

<p class="docText"><a name="want to"></a>If we want to call methods
that have unsupported data types in their parameter list, we can
use <tt>QAxBase::queryInterface()</tt><a name="to retrieve"></a> to
retrieve the COM interface and call the method directly. As usual
with COM, we must call <tt>Release()</tt><a name=
"have finished"></a> when we have finished using the interface. If
we often need to call such methods, we can subclass
<tt>QAxObject</tt> or <tt>QAxWidget</tt><a name=
"provide member"></a> and provide member functions that encapsulate
the COM interface calls. Be aware that <tt>QAxObject</tt> and
<tt>QAxWidget</tt> subclasses cannot define their own properties,
signals, or slots.</p>

<p class="docText">We will now review the <span class=
"docEmphasis">QAxServer</span><a name="program into"></a> module.
This module enables us to turn a standard Qt program into an
ActiveX server. The server can be either a shared library or a
stand-alone application. Servers built as shared libraries are
often called <span class="docEmphasis">in-process servers</span>;
stand-alone applications are called <span class=
"docEmphasis">out-of-process servers</span>.</p>

<p class="docText">Our first <span class=
"docEmphasis">QAxServer</span><a name="provides a"></a> example is
an in-process server that provides a widget that shows a ball
bouncing left and right. We will also see how to embed the widget
in Internet Explorer.</p>

<p class="docText">Here's the beginning of the class definition of
the <tt>AxBouncer</tt> widget:</p>

<div class="docText">
<pre>
class AxBouncer : public QWidget, public QAxBindable
{
    Q_OBJECT
    Q_ENUMS(SpeedValue)
    Q_PROPERTY(QColor color READ color WRITE setColor)
    Q_PROPERTY(SpeedValue speed READ speed WRITE setSpeed)
    Q_PROPERTY(int radius READ radius WRITE setRadius)
    Q_PROPERTY(bool running READ isRunning)
</pre>
</div>
<br>

<p class="docText"><a name="iddle3808"></a><a name=
"iddle3860"></a><a name="iddle3948"></a><a name=
"iddle4594"></a><a name="iddle5438"></a><a name=
"iddle7471"></a><a name="iddle7542"></a><tt>AxBouncer</tt>, shown
in <a class="docLink" href="#ch23fig06">Figure 23.6</a>, is derived
from both <tt>QWidget</tt> and <tt>QAxBindable</tt>. The
<tt>QAxBindable</tt><a name="ActiveX client"></a> class provides an
interface between the widget and an ActiveX client. Any
<tt>QWidget</tt><a name="by subclassing"></a> can be exported as an
ActiveX control, but by subclassing <tt>QAxBindable</tt><a name=
"can implement"></a> we can notify the client when a property's
value changes, and we can implement COM interfaces to supplement
those already implemented by <span class=
"docEmphasis">QAxServer</span>.</p>
<a name="ch23fig06"></a>
<center>
<h5 class="docFigureTitle">Figure 23.6. The <tt>AxBouncer</tt>
widget in Internet Explorer</h5>

<p class="docText"><img border="0" id="" width="446" height="468"
src=
"images/NzlkOW1jM2FhMDc4L2lwdHJnZTFnMTRzOXIvMy83cC5vaHVwZ2ovaXNibmNjZXI-.jpg"
alt="">
</p>
</center>
<br>

<p class="docText"><a name="inheritance involving"></a>When doing
multiple inheritance involving a <tt>QObject</tt><a name=
"always put"></a>-derived class, we must always put the
<tt>QObject</tt><a name="class first"></a>-derived class first so
that <tt>moc</tt><a name="it up"></a> can pick it up.</p>

<p class="docText"><a name="declare three"></a>We declare three
read-write properties and one read-only property. The
<tt>Q_ENUMS()</tt> macro is necessary to tell <tt>moc</tt> that the
<tt>SpeedValue</tt><a name="the public"></a> type is an enum type.
The enum is declared in the public section of the class:</p>

<div class="docText">
<pre>
public:
    enum SpeedValue { Slow, Normal, Fast };

    AxBouncer(QWidget *parent = 0);

    void setSpeed(SpeedValue newSpeed);
    SpeedValue speed() const { return ballSpeed; }
    void setRadius(int newRadius);
    int radius() const { return ballRadius; }
    void setColor(const QColor &amp;newColor);
    QColor color() const { return ballColor; }
    bool isRunning() const { return myTimerId != 0; }
    QSize sizeHint() const;
    QAxAggregated *createAggregate();

public slots:
    void start();
    void stop();

signals:
    void bouncing();
</pre>
</div>
<br>

<p class="docText"><a name="iddle1267"></a><a name=
"iddle1269"></a><a name="iddle2682"></a><a name=
"iddle4110"></a><a name="iddle4538"></a><a name=
"iddle4548"></a><a name="iddle4758"></a><a name=
"iddle4759"></a><a name="iddle4765"></a><a name=
"iddle6883"></a><a name="iddle7148"></a><a name="iddle8584"></a>The
<tt>AxBouncer</tt><a name="for a"></a> constructor is a standard
constructor for a widget, with a <tt>parent</tt> parameter. The
<tt>QAXFACTORY_DEFAULT()</tt><a name="constructor with"></a> macro,
which we will use to export the component, expects a constructor
with this signature.</p>

<p class="docText">The <tt>createAggregate()</tt> function is
reimplemented from <tt>QAxBindable</tt>. We will explain it in a
moment.</p>

<div class="docText">
<pre>
protected:
    void paintEvent(QPaintEvent *event);
    void timerEvent(QTimerEvent *event);

private:
    int intervalInMilliseconds() const;

    QColor ballColor;
    SpeedValue ballSpeed;
    int ballRadius;
    int myTimerId;
    int x;
    int delta;
};
</pre>
</div>
<br>

<p class="docText"><a name="class are"></a>The protected and
private sections of the class are the same as those we would have
if this was a standard Qt widget.</p>

<div class="docText">
<pre>
AxBouncer::AxBouncer(QWidget *parent)
    : QWidget(parent)
{
    ballColor = Qt::blue;
    ballSpeed = Normal;
    ballRadius = 15;
    myTimerId = 0;
    x = 20;
    delta = 2;
}
</pre>
</div>
<br>

<p class="docText">The <tt>AxBouncer</tt> constructor initializes
the class's private variables.</p>

<div class="docText">
<pre>
void AxBouncer::setColor(const QColor &amp;newColor)
{
    if (newColor != ballColor &amp;&amp; requestPropertyChange("color")) {
        ballColor = newColor;
        update();
        propertyChanged("color");
    }
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle1104"></a><a name=
"iddle1268"></a><a name="iddle1270"></a><a name=
"iddle1271"></a><a name="iddle1272"></a><a name=
"iddle1273"></a><a name="iddle1853"></a><a name=
"iddle1899"></a><a name="iddle3259"></a><a name=
"iddle3307"></a><a name="iddle3374"></a><a name=
"iddle4084"></a><a name="iddle4749"></a><a name=
"iddle4750"></a><a name="iddle4757"></a><a name=
"iddle6423"></a><a name="iddle6424"></a><a name=
"iddle6844"></a><a name="iddle7296"></a><a name=
"iddle7329"></a><a name="iddle7708"></a><a name=
"iddle7770"></a><a name="iddle7819"></a><a name="iddle7827"></a>The
<tt>setColor()</tt> function sets the value of the <tt>color</tt>
property. It calls <tt>update()</tt> to repaint the widget.</p>

<p class="docText">The unusual part is the
<tt>requestPropertyChange()</tt> and <tt>propertyChanged()</tt>
calls. These functions are inherited from <tt>QAxBindable</tt> and
should ideally be called whenever we change a property. The
<tt>requestPropertyChange()</tt> asks the client's permission to
change a property, and returns <tt>true</tt> if the client allows
the change. The <tt>propertyChanged()</tt> function notifies the
client that the property has been changed.</p>

<p class="docText">The <tt>setSpeed()</tt> and <tt>setRadius()</tt>
setters also follow this pattern, and so do the <tt>start()</tt>
and <tt>stop()</tt> slots, since they change the value of the
<tt>running</tt> property.</p>

<p class="docText">One interesting <tt>AxBouncer</tt> member
function is left:</p>

<div class="docText">
<pre>
QAxAggregated *AxBouncer::createAggregate()
{
    return new ObjectSafetyImpl;
}
</pre>
</div>
<br>

<p class="docText">The <tt>createAggregate()</tt> function is
reimplemented from <tt>QAxBindable</tt>. It allows us to implement
COM interfaces that the <span class="docEmphasis">QAxServer</span>
module doesn't already implement or to bypass <span class=
"docEmphasis">QAxServer</span>'s default COM interfaces. Here, we
do it to provide the <tt>IObjectSafety</tt><a name=
"the standard"></a> interface, which Internet Explorer uses to
access a component's safety options. This is the standard trick to
get rid of Internet Explorer's infamous "Object not safe for
scripting" error message.</p>

<p class="docText"><a name="the class"></a>Here's the definition of
the class that implements the <tt>IObjectSafety</tt> interface:</p>

<div class="docText">
<pre>
class ObjectSafetyImpl : public QAxAggregated, public IObjectSafety
{
public:
    long queryInterface(const QUuid &amp;iid, void **iface);

    QAXAGG_IUNKNOWN

    HRESULT WINAPI GetInterfaceSafetyOptions(REFIID riid,
            DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    HRESULT WINAPI SetInterfaceSafetyOptions(REFIID riid,
            DWORD pdwSupportedOptions, DWORD pdwEnabledOptions);
};
</pre>
</div>
<br>

<p class="docText">The <tt>ObjectSafetyImpl</tt><a name=
"derived from"></a> class is derived from both
<tt>QAxAggregated</tt><a name="and"></a> and
<tt>IObjectSafety</tt>. The <tt>QAxAggregated</tt><a name=
"an abstract"></a> class is an abstract base class for
implementations of additional COM interfaces. The COM object that
the <tt>QAxAggregated</tt><a name="is accessible"></a> extends is
accessible through <tt>controllingUnknown()</tt>. The <span class=
"docEmphasis">QAxServer</span> module creates this COM object
behind the scenes.</p>

<p class="docText">The <tt>QAXAGG_IUNKNOWN</tt> macro provides
standard implementations of <tt>QueryInterface()</tt>,
<tt>AddRef()</tt>, and <tt>Release()</tt><a name=
"controlling COM"></a>. These implementations simply call the same
functions on the controlling COM object.</p>

<div class="docText">
<pre>
long ObjectSafetyImpl::queryInterface(const QUuid &amp;iid, void **iface)
{
    *iface = 0;
    if (iid == IID_IObjectSafety) {
        *iface = static_cast&lt;IObjectSafety *&gt;(this);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}
</pre>
</div>
<br>

<p class="docText"><a name="iddle2683"></a><a name=
"iddle2914"></a><a name="iddle4766"></a><a name="iddle7250"></a>The
<tt>queryInterface()</tt><a name="function of"></a> function is a
pure virtual function of <tt>QAxAggregated</tt><a name=
"give access"></a>. It is called by the controlling COM object to
give access to the interfaces provided by the
<tt>QAxAggregated</tt> subclass. We must return
<tt>E_NOINTERFACE</tt> for interfaces that we don't implement and
for <tt>IUnknown</tt>.</p>

<div class="docText">
<pre>
HRESULT WINAPI ObjectSafetyImpl::GetInterfaceSafetyOptions(
        REFIID /* riid */, DWORD *pdwSupportedOptions,
        DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA
                           | INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    *pdwEnabledOptions = *pdwSupportedOptions;
    return S_OK;
}

HRESULT WINAPI ObjectSafetyImpl::SetInterfaceSafetyOptions(
        REFIID /* riid */, DWORD /* pdwSupportedOptions */,
        DWORD /* pdwEnabledOptions */)
{
    return S_OK;
}
</pre>
</div>
<br>

<p class="docText">The <tt>GetInterfaceSafetyOptions()</tt> and
<tt>SetInterfaceSafetyOptions()</tt> functions are declared in
<tt>IObjectSafety</tt><a name="that our"></a>. We implement them to
tell the world that our object is safe for scripting.</p>

<p class="docText">Let's now review <tt>main.cpp</tt>:</p>

<div class="docText">
<pre>
#include &lt;QAxFactory&gt;

#include"axbouncer.h"

QAXFACTORY_DEFAULT(AxBouncer,
                   "{5e2461aa-a3e8-4f7a-8b04-307459a4c08c}",
                   "{533af11f-4899-43de-8b7f-2ddf588d1015}",
                   "{772c14a5-a840-4023-b79d-19549ece0cd9}",
                   "{dbce1e56-70dd-4f74-85e0-95c65d86254d}",
                   "{3f3db5e0-78ff-4e35-8a5d-3d3b96c83e09}")
</pre>
</div>
<br>

<p class="docText">The <tt>QAXFACTORY_DEFAULT()</tt><a name=
"servers that"></a> macro exports an ActiveX control. We can use it
for ActiveX servers that export only one control. The next example
in this section will show how to export many ActiveX controls.</p>

<p class="docText"><a name="to"></a>The first argument to
<tt>QAXFACTORY_DEFAULT()</tt><a name="name of"></a> is the name of
the Qt class to export. This is also the name under which the
control is exported. The other five <a name=
"iddle1117"></a><a name="iddle1118"></a><a name=
"iddle1735"></a><a name="iddle2053"></a><a name=
"iddle2563"></a><a name="iddle2564"></a><a name=
"iddle3081"></a><a name="iddle3129"></a><a name=
"iddle3390"></a><a name="iddle3745"></a><a name=
"iddle3816"></a><a name="iddle4468"></a><a name=
"iddle4512"></a><a name="iddle4582"></a><a name=
"iddle5324"></a><a name="iddle5339"></a><a name=
"iddle6746"></a><a name="iddle6827"></a><a name=
"iddle7003"></a><a name="iddle7851"></a><a name=
"iddle8467"></a><a name="arguments are"></a>arguments are the class
ID, the interface ID, the event interface ID, the type library ID,
and the application ID. We can use standard tools such as
<tt>guidgen</tt> or <tt>uuidgen</tt><a name=
"these identifiers"></a> to generate these identifiers. Because the
server is a library, we don't need a <tt>main()</tt> function.</p>

<p class="docText">Here's the <tt>.pro</tt><a name="for our"></a>
file for our in-process ActiveX server:</p>

<div class="docText">
<pre>
TEMPLATE       = lib
CONFIG        += dll qaxserver
HEADERS        = axbouncer.h \
                 objectsafetyimpl.h
SOURCES        = axbouncer.cpp \
                 main.cpp \
                 objectsafetyimpl.cpp
RC_FILE        = qaxserver.rc
DEF_FILE       = qaxserver.def
</pre>
</div>
<br>

<p class="docText">The <tt>qaxserver.rc</tt> and
<tt>qaxserver.def</tt> files referred to in the <tt>.pro</tt> file
are standard files that can be copied from Qt's
<tt>src\activeqt\control</tt> directory.</p>

<p class="docText">The makefile or Visual C++ project file
generated by <tt>qmake</tt><a name="To register"></a> contains
rules to register the server in the Windows registry. To register
the server on end-user machines, we can use the <tt>regsvr32</tt>
tool available on all Windows systems.</p>

<p class="docText"><a name="Bouncer component"></a>We can then
include the Bouncer component in an HTML page using the
<tt>&lt;object&gt;</tt> tag:</p>

<div class="docText">
<pre>
&lt;object id="AxBouncer"
        classid="clsid:5e2461aa-a3e8-4f7a-8b04-307459a4c08c"&gt;
&lt;b&gt;The ActiveX control is not available. Make sure you have built and
registered the component server.&lt;/b&gt;
&lt;/object&gt;
</pre>
</div>
<br>

<p class="docText">We can create buttons that invoke slots:</p>

<div class="docText">
<pre>
&lt;input type="button" value="Start" onClick="AxBouncer.start()"&gt;
&lt;input type="button" value="Stop" onClick="AxBouncer.stop()"&gt;
</pre>
</div>
<br>

<p class="docText"><a name="just like"></a>We can manipulate the
widget using JavaScript or VBScript just like any other ActiveX
control. See the <tt>demo.html</tt><a name="rudimentary page"></a>
file included with the book's examples for a rudimentary page that
uses the ActiveX server.</p>

<p class="docText"><a name="can serve"></a>Our last example is a
scriptable Address Book application. The application can serve as a
standard Qt/Windows application or an out-of-process ActiveX
server. The latter possibility allows us to script the application
using, say, Visual Basic.</p>

<div class="docText">
<div class="codeSegmentsExpansionLinks">Code View:</div>

<pre class="">
class AddressBook : public QMainWindow
{
    Q_OBJECT
    Q_PROPERTY(int count READ count)
    Q_CLASSINFO("ClassID", "{588141ef-110d-4beb-95ab-ee6a478b576d}")
    Q_CLASSINFO("InterfaceID", "{718780ec-b30c-4d88-83b3-79b3d9e78502}")
    Q_CLASSINFO("ToSuperClass", "AddressBook")
public:
    AddressBook(QWidget *parent = 0);
    ~AddressBook();

    int count() const;

public slots:
    ABItem *createEntry(const QString &amp;contact);
    ABItem *findEntry(const QString &amp;contact) const;
    ABItem *entryAt(int index) const;

private slots:
    void addEntry();
    void editEntry();
    void deleteEntry();

private:
    void createActions();
    void createMenus();

    QTreeWidget *treeWidget;
    QMenu *fileMenu;
    QMenu *editMenu;
    QAction *exitAction;
    QAction *addEntryAction;
    QAction *editEntryAction;
    QAction *deleteEntryAction;
};

                                          
</pre>
</div>
<br>

<p class="docText"><a name="iddle2684"></a><a name=
"iddle4760"></a><a name="iddle4763"></a><a name=
"iddle4767"></a><a name="iddle4768"></a><a name=
"iddle4770"></a><a name="iddle4775"></a>The
<tt>AddressBook</tt><a name="main window"></a> widget is the
application's main window. The widget's property and its public
slots will be available for scripting. The
<tt>Q_CLASSINFO()</tt><a name="used to"></a> macro is used to
specify the class and interface IDs associated with the class.
These were generated using a tool such as <tt>guid</tt><a name=
"or"></a> or <tt>uuid</tt>.</p>

<p class="docText"><a name="previous example"></a>In the previous
example, we specified the class and interface IDs when we exported
the <tt>QAxBouncer</tt><a name="using the"></a> class using the
<tt>QAXFACTORY_DEFAULT()</tt><a name="cannot use"></a> macro. In
this example, we want to export several classes, so we cannot use
<tt>QAXFACTORY_DEFAULT()</tt>. Two options are available to us:</p>

<ul>
<li>
<p class="docList">We can subclass <tt>QAxFactory</tt><a name=
"provide information"></a>, reimplement its virtual functions to
provide information about the types we want to export, and use the
<tt>QAXFACTORY_EXPORT()</tt> macro to register the factory.</p>
</li>

<li>
<p class="docList">We can use the <tt>QAXFACTORY_BEGIN()</tt>,
<tt>QAXFACTORY_END()</tt>, <tt>QAXCLASS()</tt>, and
<tt>QAXTYPE()</tt><a name="us to"></a> macros to declare and
register the factory. This approach requires us to specify the
class and interface IDs using <tt>Q_CLASSINFO()</tt>.</p>
</li>
</ul>

<p class="docText">Back to the <tt>AddressBook</tt> class
definition: The third occurrence of <tt>Q_CLASSINFO()</tt><a name=
"expose not"></a> may seem a bit mysterious. By default, ActiveX
controls expose not only their own properties, signals, and slots
to clients, but also those of their ancestors up to
<tt>QWidget</tt>. The <tt>ToSuperClass</tt><a name="tree that"></a>
attribute lets us specify the highest ancestor in the inheritance
tree that we want to expose. Here, we specify the class name of the
component (<tt>AddressBook</tt><a name="ancestor to"></a>) as the
highest ancestor to export, meaning that <a name=
"iddle1045"></a><a name="iddle1082"></a><a name=
"iddle1693"></a><a name="iddle3657"></a><a name=
"iddle5442"></a><a name="iddle6408"></a><a name=
"iddle6826"></a><a name="iddle7854"></a><a name=
"iddle7867"></a><a name="iddle8316"></a><a name=
"inherited from"></a>properties, signals, and slots inherited from
<tt>AddressBook</tt><a name="own ancestors"></a>'s own ancestors
will not be exported.</p>

<div class="docText">
<pre>
class ABItem : public QObject, public QTreeWidgetItem
{
    Q_OBJECT
    Q_PROPERTY(QString contact READ contact WRITE setContact)
    Q_PROPERTY(QString address READ address WRITE setAddress)
    Q_PROPERTY(QString phoneNumber READ phoneNumber
               WRITE setPhoneNumber)
    Q_CLASSINFO("ClassID", "{bc82730e-5f39-4e5c-96be-461c2cd0d282}")
    Q_CLASSINFO("InterfaceID", "{c8bc1656-870e-48a9-9937-fbe1ceff8b2e}")
    Q_CLASSINFO("ToSuperClass", "ABItem")

public:
    ABItem(QTreeWidget *treeWidget);

    void setContact(const QString &amp;contact);
    QString contact() const { return text(0); }
    void setAddress(const QString &amp;address);
    QString address() const { return text(1); }
    void setPhoneNumber(const QString &amp;number);
    QString phoneNumber() const { return text(2); }

public slots:
    void remove();
};
</pre>
</div>
<br>

<p class="docText">The <tt>ABItem</tt><a name="one entry"></a>
class represents one entry in the address book. It is derived from
<tt>QTreeWidgetItem</tt><a name="that it"></a> so that it can be
shown in a <tt>QTreeWidget</tt> and from <tt>QObject</tt> so that
it can be exported as a COM object.</p>

<div class="docText">
<pre>
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    if (!QAxFactory::isServer()) {
        AddressBook addressBook;
        addressBook.show();
        return app.exec();
    }
    return app.exec();
}
</pre>
</div>
<br>

<p class="docText">In <tt>main()</tt><a name="as a"></a>, we check
whether the application is being run stand-alone or as a server.
The <tt>-activex</tt> command-line option is recognized by
<tt>QApplication</tt><a name="as a"></a> and makes the application
run as a server. If the application isn't run as a server, we
create the main widget and show it as we would normally do in any
stand-alone Qt application.</p>

<p class="docText">In addition to <tt>-activex</tt>, ActiveX
servers understand the following command-line options:</p>

<ul>
<li>
<p class="docList"><tt>-regserver</tt> registers the server in the
system registry.</p>
</li>

<li>
<p class="docList"><tt>-unregserver</tt> unregisters the server
from the system registry.</p>
</li>

<li>
<p class="docList"><a name="iddle1736"></a><a name=
"iddle2313"></a><a name="iddle2685"></a><a name=
"iddle3139"></a><a name="iddle3256"></a><a name=
"iddle4469"></a><a name="iddle4761"></a><a name=
"iddle4764"></a><a name="iddle4769"></a><a name=
"iddle4776"></a><a name="iddle6747"></a><a name=
"iddle7120"></a><a name="iddle8616"></a><a name=
"iddle8688"></a><tt>-dumpidl</tt> <span class=
"docEmphasis"><tt>file.idl</tt></span> writes the server's IDL to
the specified file.</p>
</li>
</ul>

<p class="docText"><a name="export the"></a>When the application is
run as a server, we must export the <tt>AddressBook</tt> and
<tt>ABItem</tt> classes as COM components:</p>

<div class="docText">
<pre>
QAXFACTORY_BEGIN("{2b2b6f3e-86cf-4c49-9df5-80483b47f17b}",
                 "{8e827b25-148b-4307-ba7d-23f275244818}")
QAXCLASS(AddressBook)
QAXTYPE(ABItem)
QAXFACTORY_END()
</pre>
</div>
<br>

<p class="docText"><a name="creating COM"></a>The preceding macros
export a factory for creating COM objects. Since we want to export
two types of COM objects, we cannot simply use
<tt>QAXFACTORY_DEFAULT()</tt> as we did in the previous
example.</p>

<p class="docText">The first argument to
<tt>QAXFACTORY_BEGIN()</tt><a name="Between"></a> is the type
library ID; the second argument is the application ID. Between
<tt>QAXFACTORY_BEGIN()</tt> and <tt>QAXFACTORY_END()</tt><a name=
"the classes"></a>, we specify all the classes that can be
instantiated and all the data types that we want to make accessible
as COM objects.</p>

<p class="docText"><a name="the"></a>This is the
<tt>.pro</tt><a name="file for"></a> file for our out-of-process
ActiveX server:</p>

<div class="docText">
<pre>
TEMPLATE      = app
CONFIG       += qaxserver
HEADERS       = abitem.h \
                addressbook.h \
                editdialog.h
SOURCES       = abitem.cpp \
                addressbook.cpp \
                editdialog.cpp \
                main.cpp
FORMS         = editdialog.ui
RC_FILE       = qaxserver.rc
</pre>
</div>
<br>

<p class="docText">The <tt>qaxserver.rc</tt><a name="to in"></a>
file referred to in the <tt>.pro</tt><a name="is a"></a> file is a
standard file that can be copied from Qt's
<tt>src\activeqt\control</tt> directory.</p>

<p class="docText">Look in the example's <tt>vb</tt><a name=
"Address Book"></a> directory for a Visual Basic project that uses
the Address Book server.</p>

<p class="docText"><a name="the ActiveQt"></a>This completes our
overview of the ActiveQt framework. The Qt distribution includes
additional examples, and the documentation contains information
about how to build the <span class=
"docEmphasis">QAxContainer</span> and <span class=
"docEmphasis">QAxServer</span> modules and how to solve common
interoperability issues.</p>
</div>
</div>

<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td align="right">
<div style="MARGIN-LEFT: 0.15in;"><a href=
"ch23lev1sec1.html"><img src="images/prev.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Previous Page"></a> <a href=
"ch23lev1sec3.html"><img src="images/next.gif" width="20" height=
"20" border="0" align="absmiddle" alt="Next Page"></a></div>
</td>
</tr>
</table>

<script type="text/JavaScript">
var fe = FindFrame("toc", top);
if ((fe != null) && (chmtop.c2wtopf.jstree != null)) {
  if (chmtop.c2wtopf.FITEMS[chmtop.c2wtopf.pagenum] != chmtop.c2wtopf.pageid)
    chmtop.c2wtopf.jstree.OpenTreeNode("sources/" + chmtop.c2wtopf.pageid);
}
</script>

<!-- CHM2WEB -->
<!-- DO NOT DELETE OR MODIFY THIS CODE WITHOUT 
     WRITTEN PERMISSION OF A!K RESEARCH LABS -->
<table width="100%" cellspacing="0" cellpadding="0" 
style="margin-top: 0pt; border-collapse: collapse;"> 
<tr> <td align="right" style="background-color:white; border-top: 1px solid gray;"> 
<a href="http://chm2web.aklabs.com" target="_blank" style="font-family: sans-serif;  font-size: 11px; text-decoration: none;"><font color="gray">Converted from CHM to HTML with <b>chm2web Pro 2.85 (unicode)</b></font></a>
</td></tr></table> 
<!-- /CHM2WEB -->

</body>
</html>
